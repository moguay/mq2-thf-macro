| BotHeal by moguay

Sub Main

    /if (!${Defined[MacroSupport]}) /declare MacroSupport string local [+r+]#[+x+] [+m+]You like and want to support this development[+x+], [+r+]you can donate[+x+]: https://paypal.me/moguay

| Class exclusion
    /if (!${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL,RNG,BST]} && !${Select[${Me.Class.ShortName},SHD,NEC,ENC,MAG]}) {
        /docommand /bct ${Me.CleanName} ${MacroSupport}
        /delay 1
        /echo Exit, not a healer class.
        /return
    }

| Plugins
    /if (!${Plugin[MQ2Cast].Name.Equal[MQ2Cast]})                               /plugin MQ2Cast
    /if (!${Plugin[MQ2EQBC].Name.Equal[MQ2EQBC]})                               /plugin MQ2EQBC
    /if (!${Plugin[MQ2ChatWnd].Name.Equal[MQ2ChatWnd]})                         /plugin mq2chatwnd

    | /if (!${Plugin[mq2custombinds].Name.Equal[mq2custombinds]})                 /plugin mq2custombinds
    | /if (!${Plugin[mq2emusearch].Name.Equal[mq2emusearch]})                     /plugin mq2emusearch
    /if (!${Plugin[mq2labels].Name.Equal[mq2labels]})                           /plugin mq2labels
    /if (!${Plugin[mq2map].Name.Equal[mq2map]})                                 /plugin mq2map

    /if (!${Plugin[MQ2NetBots].Name.Equal[MQ2NetBots]})                         /plugin MQ2NetBots auto
    /if (!${Plugin[MQ2NetHeal].Name.Equal[MQ2NetHeal]})                         /plugin MQ2NetHeal auto
    /if (!${Plugin[MQ2MoveUtils].Name.Equal[MQ2MoveUtils]})                     /plugin MQ2MoveUtils
    | /if (!${Plugin[MQ2Buffblock].Name.Equal[MQ2Buffblock]})                     /plugin MQ2Buffblock
    /if (!${Plugin[MQ2Exchange].Name.Equal[MQ2Exchange]})                       /plugin MQ2Exchange
    | /if (!${Plugin[MQ2EmuAutoMacro].Name.Equal[MQ2EmuAutoMacro]})               /plugin MQ2EmuAutoMacro
    /if (!${Plugin[MQ2AutoGroup].Name.Equal[MQ2AutoGroup]})                     /plugin MQ2AutoGroup
    /if (!${Plugin[MQ2AutoLogin].Name.Equal[MQ2AutoLogin]})                     /squelch /plugin MQ2AutoLogin
    | /if (!${Plugin[MQ2EmuMouseAPI].Name.Equal[MQ2EmuMouseAPI]})                 /plugin MQ2EmuMouseAPI
    | /if (!${Plugin[MQ2EmuArt].Name.Equal[MQ2EmuArt]})                           /plugin MQ2EmuArt
    /if (!${Plugin[MQ2ItemDisplay].Name.Equal[MQ2ItemDisplay]})                 /plugin MQ2ItemDisplay

    /if (${Plugin[MQ2Vmqnet].Name.Equal[MQ2Vmqnet]})                            /plugin MQ2Vmqnet unload
    /if (${Plugin[MQ2EmuNetAdvPath].Name.Equal[MQ2EmuNetAdvPath]})              /plugin MQ2EmuNetAdvPath unload
    /if (${Plugin[MQ2EmuMap].Name.Equal[MQ2EmuMap]})                            /plugin MQ2EmuMap unload
    /if (${Plugin[MQ2EmuCharacters].Name.Equal[MQ2EmuCharacters]})              /plugin MQ2EmuCharacters unload
    /if (${Plugin[MQ2DPSAdv].Name.Equal[MQ2DPSAdv]})                            /plugin MQ2DPSAdv unload
    /if (${Plugin[MQ2Melee].Name.Equal[MQ2Melee]})                              /plugin MQ2Melee unload
    /if (${Plugin[MQ2Tracking].Name.Equal[MQ2Tracking]})                        /plugin MQ2Tracking unload

    /if (${Plugin[MQ2Twist].Name.Equal[MQ2Twist]})                              /plugin MQ2Twist unload

    /if (!${Plugin[MQ2FPS].Name.Equal[MQ2FPS]})                                 /plugin MQ2FPS noauto

    /if (!${Plugin[MQ2Turbo].Name.Equal[MQ2Turbo]})                             /squelch /plugin MQ2Turbo
    /if (${Plugin[MQ2Turbo].Name.Equal[MQ2Turbo]})                              /squelch /turbo 80

| Global configuration
    /squelch /netbot on send=on grab=on
    /squelch /netheal on send=on grab=on

    /squelch /mqfont 1

| Broadcast messages
    /call Define_Echo

    /if (!${Defined[MacroHealVersion]})     /declare MacroHealVersion       string  local  0.9.1

    /if (!${Defined[broadcast]})            /declare broadcast              int     outer   1
    /if (!${Defined[broadcastList]})        /declare broadcastList          string  outer   SHEAL GHEAL
    /if (!${Defined[broadcastMsg]})         /declare broadcastMsg           string  outer   /bcaa //${echo} [${Me.CleanName}]
    /if (!${Defined[chat]})                 /declare chat                   string  outer   /${echo}

    | % Single Target Tank heal
    /if (!${Defined[autohealpctTK]})        /declare autohealpctTK          int     outer   80
    | % Single Target Other heal
    /if (!${Defined[autohealpctST]})        /declare autohealpctST          int     outer   70
    | % Group heal
    /if (!${Defined[autohealpctGT]})        /declare autohealpctGT          int     outer   80
    | % self pal heal
    /if (!${Defined[autohealpctMT]})        /declare autohealpctMT          int     outer   90
    | % AA divine
    /if (!${Defined[divinearbpct]})         /declare divinearbpct           int     outer   25
    | % ManaCheck
    /if (!${Defined[Manastart]})            /declare Manastart              int     outer   8
    | % ManaMantenance
    /if (!${Defined[ManaMainteance]})       /declare ManaMainteance         int     outer   50
    | Compatility Code Variable
    /if (!${Defined[autohealpctSHIFT]})     /declare autohealpctSHIFT       int     outer   ${autohealpctTK}
    /if (!${Defined[autohealpctPARALLEL]})  /declare autohealpctPARALLEL    int     outer   ${autohealpctST}
    /if (!${Defined[autogrouppct]})         /declare autogrouppct           int     outer   ${autohealpctGT}
    /if (!${Defined[autogroupcount]})       /declare autogroupcount         int     outer   2
| Debug
    /if (!${Defined[DebugList]})            /declare DebugList              string  outer

| Futur feat
    /if (!${Defined[HealTarget]})           /declare HealTarget             int     outer   0
    /if (!${Defined[HealType]})             /declare HealType               string  outer   0


| Initialisation
    /call Define_CastingWindow
    /call Define_ChaoticAttuning
    /call Define_THF_Spells

| Starting brodcast
    /docommand /${echo} ${Cr}--------------------------------------------------------${Cx}
    /docommand /${echo} ** ${Ct}Moguay${Cx}'s Heal Macro v${MacroHealVersion} started **
    /docommand /${echo} ${Cr}--------------------------------------------------------${Cx}
    /if (${turbo}) {
        /docommand /${echo} - macro turbo set to : ${Cg}${turbo}${Cx}
    }
    /if (${Select[${Me.Class.ShortName},SHD,NEC,ENC,MAG]}) {
        /docommand /${echo} - ${Cr}Only${Cx} pet heal and mana management running...
    } else {
        /docommand /${echo} - ${Cy}${NetWorst.Request[pc all100]}${Cx} players in my scan
    }

    /echo Features:
    /echo - 0 config
    /echo - Heal buff
    /echo - Geather and maintenance mana
    /echo - Group heal with fast casting
    /echo - Bots heal, prio heal with Parallel casting
    /echo - Self, AA, Target, Pet and Raid heal

    /docommand /bct ${Me.CleanName} ${MacroSupport}

:Loop
| Wait during casting, !stand, stun, move, silence
    | /call CheckCasting 0 FALSE True
    /call CheckCasting
    /if (${Macro.Return}) {
        /delay 5
        /goto :loop
    }

| Mana Maintenance
    /call ManMaintenance
    /if (${Macro.Return}) /goto :Loop

| Geather Mana
    /if (${Me.PctMana}<=${Manastart}) {
        /call ManaCheck
        /if (${Macro.Return}) /goto :Loop
    }
    
| Pet Heal for non healer class
    /if (${Select[${Me.Class.ShortName},SHD,NEC,ENC,MAG]}) {
        /if (${Me.Pet.ID}) /call HealMyPet
        /goto :Loop
    }

| Auto Set HealTarget to Self


| Check to see if Divine Arb needs to be cast.
    /if (${Me.Class.Name.Equal[Cleric]}) {
        /Call DivineArb
        /if (${Macro.Return}) /goto :Loop
    }

| Check to see if Lay on Hands needs to be cast.
    /if (${Me.Class.Name.Equal[Paladin]}) {
        /Call LayonHands
        /if (${Macro.Return}) /goto :Loop
    }
    
| Manual SingleTarget
    /if (${Spawn[pc ${HealTarget}].ID}!=NULL) {
        /call HealSingleTarget
        /if (${Macro.Return}) /goto :Loop
    }

| Spam Heals if SPAM setting is enabled.
    /if (${HealType.Equal[SPAM]}) {
        /Call HealSpam
        /goto :Loop
    }

| Spam Heals if FIX Healing setting is enabled.
    /if (${HealType.Equal[FIX]} && ${Spawn[${HealTarget}].ID}) {
        /Call HealFix
        /if (${Macro.Return}) /goto :Loop
    }

| Check to see if a group heal is required.
    /Call HealGroup
    /if (${Macro.Return}) /goto :Loop

| Check to see if pal self heal is required.
    /Call PalSelfHeal
    /if (${Macro.Return}) /goto :Loop

| Check to see if single heal is required.
    /call HealSingleTargetCheck
    /if (${Macro.Return}) /goto :Loop

/goto :Loop

/return


Sub HealSingleTargetCheck

| Push new value (manualy change)
    /varset autohealpctSHIFT ${autohealpctTK}
    /varset autohealpctPARALLEL ${autohealpctST}

| Tank Shift Heal
    /declare HealerShift    int local   2
    /declare CountTankNeed  int     local   ${NetWorst.Request[radius${Int[${Spell[${spellSingleHeal}].MyRange}]} pc war${autohealpctSHIFT} shd${autohealpctSHIFT}]}
    /declare TankNeedID     string  local
    /varset TankNeedID                      ${NetWorst.Members.Arg[1, ]}
| Count heal needed
    /declare CountAllNeed   int     local   ${NetWorst.Request[radius${Int[${Spell[${spellSingleHeal}].MyRange}]} pc all${autohealpctPARALLEL}]}
    /declare WorstListID    string  local
    /varset WorstListID                     ${NetWorst.Members}
    /if (${WorstListID.Find[ ]}) /varset WorstListID ${WorstListID.Replace[ ,|]}

| Make All Healer Lists - Ordered by priority
    /if (!${Defined[i]}) /declare i int local
    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[k]}) /declare k int local
    /if (!${Defined[l]}) /declare l int local

    /declare HealerTypeList string  local   CLR|SHM|DRU|PAL|RNG

    /for j 1 to ${Math.Calc[${HealerTypeList.Count[|]}+1]}
        /declare CountHealer${HealerTypeList.Arg[${j},|]}   int     local   ${NetWorst.Request[pc ${HealerTypeList.Arg[${j},|].Lower}110]}
        /declare HealerList${HealerTypeList.Arg[${j},|]}    string  local   ${NetWorst.Members}
        /if (${HealerList${HealerTypeList.Arg[${j},|]}.Length}) {
            /if (!${Defined[HealerListID]}) {
                /declare HealerListID string  local ${HealerList${HealerTypeList.Arg[${j},|]}}
            } else {
                /varset HealerListID ${HealerListID} ${HealerList${HealerTypeList.Arg[${j},|]}}
            }
        }
        /if (${DebugList.Find[HEAL]}) /echo HealerList${HealerTypeList.Arg[${j},|]}:${HealerList${HealerTypeList.Arg[${j},|]}} # Count:${CountHealer${HealerTypeList.Arg[${j},|]}}
    /next j

    /declare CountHealer    int     local   ${Math.Calc[${CountHealerPAL} + ${CountHealerCLR} + ${CountHealerSHM} + ${CountHealerDRU} + ${CountHealerRNG}]}

    /if (${DebugList.Find[HEAL]}) /echo HealerListID:${HealerListID} # Count:${CountHealer}

| Shift heal Filter if many toons need heal
    /if (${CountAllNeed} > ${Math.Calc[${CountHealer} - ${HealerShift}]}) {
        /varset CountTankNeed
    }

| Organize All Need Heal Lists
    /if (${CountTankNeed}) {
        /if (${CountAllNeed}) {
            /varset CountAllNeed ${Math.Calc[${CountAllNeed} - 1]}
            /if (${DebugList.Find[HEAL]}) /echo >>> Before ListDelbyName WorstListID=${WorstListID}, TankNeedID=${TankNeedID}
            /call ListDelbyName WorstListID "${TankNeedID}" |
            /if (${DebugList.Find[HEAL]}) /echo >>> After ListDelbyName WorstListID=${WorstListID}.
        }
    }

| Organize Healer Lists By Priority
    /declare CountTank      int     local   0
    /declare CountMeTank    int     local   0
    /declare CountAll       int     local   0
    /declare CountMeAll     int     local   0
    /declare CountFree      int     local   0
    /declare CountMeFree    int     local   0

    /for j 1 to ${Math.Calc[${HealerTypeList.Count[|]}+1]}
        /for i 1 to ${CountHealer${HealerTypeList.Arg[${j},|]}}
            /if (${HealerList${HealerTypeList.Arg[${j},|]}.Length}) {
                /if (${CountTankNeed} && ${CountTank}<${HealerShift}        &&  !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]} &&  ${Math.Distance[${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].Y},${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].X}:${Spawn[id ${TankNeedID}].Y},${Spawn[id ${TankNeedID}].X}]} <= ${Int[${Spell[${spellSingleHeal}].MyRange}]}) {
                    /if (${DebugList.Find[HEAL]}) /echo Add CountTank PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountTank ${Math.Calc[${CountTank} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) {
                        /varset CountMeTank ${CountTank}
                        | /varset CountMeAll ${CountTank}
                        /declare PriorityType string local heal
                    }
                } else /if (${CountAllNeed} && ${CountAll}<${CountAllNeed}  &&  !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]} &&  ${Math.Distance[${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].Y},${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].X}:${Spawn[id ${WorstListID.Arg[${Math.Calc[${CountAll} + 1]},|]}].Y},${Spawn[id ${WorstListID.Arg[${Math.Calc[${CountAll} + 1]},|]}].X}]} <= ${Int[${Spell[${spellSingleHeal}].MyRange}]}) {
                    /if (${DebugList.Find[HEAL]}) /echo Add CountALL PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountAll ${Math.Calc[${CountAll} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) {
                        /varset CountMeAll ${CountAll}
                        /declare PriorityType string local cheal
                    }
                } else /if (                                                    !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]}) {
                    /if (${DebugList.Find[HEAL]} && ${DebugList.Find[ALL]}) /echo Add CountFREE PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountFree ${Math.Calc[${CountFree} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) {
                        /varset CountMeFree ${CountFree}
                        /declare PriorityType string local cheal
                    }
                }
            }
        /next i
    /next j

| Debug
    /if (${DebugList.Find[HEAL]} || ${DebugList.Find[TIC]}) {
        /if (${CountTankNeed} || ${CountAllNeed} || ${DebugList.Find[ALL]} || ${DebugList.Find[TIC]}) /echo CountTankNeed=${CountTankNeed} CountAllNeed=${CountAllNeed} CountMeTank=${CountMeTank}/${CountTank} CountMeAll=${CountMeAll}/${CountAll} CountMeFree=${CountMeFree}/${CountFree} WorstListID=${WorstListID}
    }

| Make Rotation Heal
    /if (${CountMeTank}) {
        /call function-HealSingleTarget ${TankNeedID} 100 "Tank HT" "${PriorityType}"
        /if (${Macro.Return}) /return TRUE

| Make Parallel Heal
    } else /if (${CountMeAll} || (${CountFree} >= ${CountAllNeed} && ${CountAllNeed})) {

        | Dual Parallel Heal
        /if (${CountMeFree}) {
            /varset CountMeAll ${CountMeFree}
        }

        /call function-HealSingleTarget ${WorstListID.Arg[${CountMeAll},|]} 100 "Par. HT" "${PriorityType}"
        /if (${Macro.Return}) /return TRUE

    }

| Free Healer only
    /if (${CountMeFree}) {

| Make Heal Target
        /if (${Spawn[PC =${Target.CleanName}].ID}!=NULL) {
            /call function-HealSingleTarget ${Target.ID} ${autohealpctMT} "HT" "cheal"
            /if (${Macro.Return}) /return TRUE
        }

| Make Raid Heal
        /if (${NetWorst.Request[pc all110]}<${Raid.Members}) {
            /declare WorstOtherID   int     local
            /declare WorstOtherPct  int     local   ${autohealpctGT}
            /declare WorstOther[${Math.Calc[${CountMeFree} + 1]}] int     local   0
            /varset  WorstOther[1]                  0

            /declare WorstMyCount   int     local   ${NetWorst.Request[pc all110]}
            /declare WorstMyList    string  local   |${NetWorst.Members.Replace[ ,|]}|

            /for i 1 to ${CountMeFree}
                /for j 1 to ${Raid.Members}
                    /if (!${NetBots[${Raid.Member[${j}]}].ID}!=NULL) {
                        /if (${Spawn[PC =${Raid.Member[${j}]}].PctHPs} < 80 && ${Spawn[PC =${Raid.Member[${j}]}].ID}!=NULL) {
                            /target id ${Spawn[PC =${Raid.Member[${j}]}].ID}
                            /delay 5
                        }
                        /if (!${WorstMyList.Find[|${Spawn[PC =${Raid.Member[${j}]}].ID}|]} && ${Spawn[PC =${Raid.Member[${j}]}].ID}!=NULL) {
                            /if (${Spawn[PC =${Raid.Member[${j}]}].PctHPs}>${WorstOther[${i}]} && ${Spawn[PC =${Raid.Member[${j}]}].PctHPs}<${autohealpctGT} && ${Spawn[PC =${Raid.Member[${j}]}].Distance}<290) {
                                /varset WorstOther[${Math.Calc[${i} + 1]}] ${Spawn[PC =${Raid.Member[${j}]}].PctHPs}
                                /if (${Spawn[PC =${Raid.Member[${j}]}].PctHPs}<${WorstOtherPct}) {
                                    /varset WorstOtherID ${Spawn[PC =${Raid.Member[${j}]}].ID}
                                    /varset WorstOtherPct ${Spawn[PC =${Raid.Member[${j}]}].PctHPs}
                                }
                            }
                        }
                    }
                /next j
                /varset WorstOtherPct ${autohealpctGT}
            /next i

            /if (${Spawn[id ${WorstOtherID}].ID}!=NULL) {
                /call function-HealSingleTarget ${WorstOtherID} ${autohealpctGT} "HT" "cheal"
                /if (${Macro.Return}) /return TRUE
            }
        }
    }

| Make Self Heal
    /call function-HealSingleTarget ${Me.ID} ${autohealpctMT} "HT" "cheal"
    /if (${Macro.Return}) /return TRUE

    /if (${Me.Pet.ID}) /call HealMyPet
    /if (${Macro.Return}) /return TRUE

| Make Self Heal Buff
    /call HealSelfBuff
    /if (${Macro.Return}) /return TRUE

/return FALSE


Sub HealSingleTarget

    /call function-HealSingleTarget ${Spawn[${HealTarget}].ID} ${autohealpctMT} "HT" "cheal"
    /if (${Macro.Return}) /return TRUE

/return FALSE


Sub function-HealSingleTarget(int TargetID, int HealPCT, string CastType, string PriorityType)

    /if (${Spawn[id ${TargetID}].PctHPs}>${HealPCT}) /return FALSE

    /if (${Cast.Ready[${spellSingleHeal}]}) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "${spellSingleHeal}" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /casting "${spellSingleHeal}" -targetid|${TargetID}
        /return TRUE
    } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Stone of the Spiritwalker]} && ${StoneoftheSpiritwalkerTimer}<=0) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "Stone of the Spiritwalker" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /casting "Stone of the Spiritwalker" item -targetid|${TargetID}
        /call SetGlobalTimer  StoneoftheSpiritwalkerTimer 31s
        /return TRUE
    } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Lava Embroided Cloak]} && ${LavaEmbroidedCloakTimer}<=0) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "Lava Embroided Cloak" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /casting "Lava Embroided Cloak" item -targetid|${TargetID}
        /call SetGlobalTimer  LavaEmbroidedCloakTimer 31s
        /return TRUE
    } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Symbol of Apothic Spirits]} && ${SymbolofApothicSpiritsTimer}<=0) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "Symbol of Apothic Spirits" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /casting "Symbol of Apothic Spirits" item -targetid|${TargetID}
        /call SetGlobalTimer  SymbolofApothicSpiritsTimer 31s
        /return TRUE
    } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Gloves of the Chaos Slayer]} && ${GlovesoftheChaosSlayerTimer}<=0) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "Gloves of the Chaos Slayer" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /call SetGlobalTimer  GlovesoftheChaosSlayerTimer 16s
        /casting "Gloves of the Chaos Slayer" item -targetid|${TargetID}
        /return TRUE
    } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Leather Bound Mask of Stone]} && ${LeatherBoundMaskofStoneTimer}<=0) {
        /if (${broadcast}==1) ${If[${broadcastList.Find[SHEAL]},${broadcastMsg},/${chat}]} Casting ${CastType} "Leather Bound Mask of Stone" on [ ${Spawn[id ${TargetID}].CleanName} - ${Spawn[id ${TargetID}].PctHPs}% ] - ${PriorityType}
        /casting "Leather Bound Mask of Stone" item -targetid|${TargetID}
        /call SetGlobalTimer  LeatherBoundMaskofStoneTimer 30s
        /return TRUE
    }

/return FALSE


Sub HealGroup

    /varset autogrouppct ${autohealpctGT}

    /declare i int local                0
    /declare count int local            0
    /declare count70 int local          0
    /declare count100 int local         0
    /declare countquick int local       0

    /for i 0 to ${Group.Members}
        /if (${Group.Member[${i}].PctHPs}<=${autogrouppct} && ${Group.Member[${i}].ID}!=NULL && ${Spawn[pc =${Group.Member[${i}].CleanName}].ID}!=NULL && ${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=300) {
             /if (${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=70) /varcalc count70 ${count70}+1
             /if (${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=100) /varcalc count100 ${count100}+1
             /if (${Group.Member[${i}].PctHPs}<=60) /varcalc countquick ${countquick}+1
             /varcalc count ${count}+1
        }
    /next i

    /if (${count}>=${autogroupcount}) {

        /if (${countquick} > 0) {
            | /varset CastQueue
            | /varset CastStep 0
            | /varset CastNum 0
            /if (${Me.Casting.ID} || ${Window[${CastingWindow}].Child[Casting_SpellName].Text.Length} || ${Window[CastingWindow].Open}) /stopcast
            /delay 1s (${Cast.Ready})
            /if (${Me.Moving}) {
                /keypress left
                /keypress right
                /keypress forward
                /keypress back
                /keypress forward
            }
            /if (${Me.Ducking}) /keypress DUCK
        }

        /call function-HealGroup ${count70} ${count100} ${count} ${countquick}
        /if (${Macro.Return}) /return TRUE
        
    }

/return FALSE


Sub function-HealGroup(int count70, int count100, int count, int countquick)

        /if ((${Me.Class.Name.Equal[Cleric]} || ${Me.Class.Name.Equal[Paladin]}) && !${Me.Moving}) {

            /if (${Cast.Ready[Sceptre of Marr]} && ${SceptreofMarrTimer}<=0 && ${count100}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Sceptre of Marr" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Sceptre of Marr" item
                /call SetGlobalTimer  SceptreofMarrTimer 5m
                /return TRUE

            } else /if (${Cast.Ready[Flindara, Beacon of Light]} && ${FlindaraBeaconofLightTimer}<=0 && ${count100}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Flindara, Beacon of Light" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Flindara, Beacon of Light" item
                /call SetGlobalTimer  FlindaraBeaconofLightTimer 25s
                /return TRUE

            } else /if (${Cast.Ready[Hammer of the High Priest]} && ${HammeroftheHighPriestTimer}<=0 && ${count70}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Hammer of the High Priest" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Hammer of the High Priest" item
                /call SetGlobalTimer  HammeroftheHighPriestTimer 10s
                /return TRUE

            } else /if (${Cast.Ready[${spellGroupHeal}]} && ${If[${Select[${Int[${Spell[${spellGroupHeal}].AERange}]},70,100]},${count${Int[${Spell[${spellGroupHeal}].AERange}]}},${count}]}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "${spellGroupHeal}" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "${spellGroupHeal}"
                /return TRUE

            } else /if (${Cast.Ready[Frozen Faithbringer's Breastplate]} && ${FrozenFaithbringersBreastplateTimer}<=0 && ${count70}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Frozen Faithbringer's Breastplate" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Frozen Faithbringer's Breastplate" item
                /call SetGlobalTimer FrozenFaithbringersBreastplateTimer 10m
                /return TRUE
            }
        }

        /if ((${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Druid]}) && !${Me.Moving}) {

            /if (${Cast.Ready[Immaculate Prism of Life]} && ${ImmaculatePrismofLifeTimer}<=0 && ${count70}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Immaculate Prism of Life" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Immaculate Prism of Life" item
                /call SetGlobalTimer ImmaculatePrismofLifeTimer 15s
                /return TRUE

            } else /if (${Cast.Ready[Prism of Corruption]} && ${PrismofCorruptionTimer}<=0 && ${count70}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Prism of Corruption" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Prism of Corruption" item
                /call SetGlobalTimer PrismofCorruptionTimer 15s
                /return TRUE
            }
        }

        /if ((${Me.Class.Name.Equal[Cleric]} || ${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Druid]}) && !${Me.Moving}) {
            /if (${Cast.Ready[Shadowed Boots of Luclin]} && ${ShadowedBootsofLuclinTimer}<=0 && ${count100}>=${autogroupcount}) {
                /if (${broadcast}==1) ${If[${broadcastList.Find[GHEAL]},${broadcastMsg},/${chat}]} Casting HG "Shadowed Boots of Luclin" for [ ${If[${countquick},${countquick} quick - ,]}${count}/${Math.Calc[${Group.Members}+1]} members ] - gheal
                /casting "Shadowed Boots of Luclin" item
                /call SetGlobalTimer ShadowedBootsofLuclinTimer 630s
                /return TRUE
            }
        }
    }

/return FALSE


Sub PalSelfHeal

    /if (${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[${spellBlessingNameless}]} && ${Me.PctHPs}<${autohealpctMT} && !${Me.Moving}) {
        /if (${broadcast}==1) /${chat} Casting HT "${spellBlessingNameless}" on [ Myself - ${Me.PctHPs}% ]
        /casting "${spellBlessingNameless}"
        /return TRUE
    }

/return FALSE


Sub DivineArb

    /declare i int local                0
    /declare count int local            0
    /declare worstTargetID int local    0
    /declare worstTargetPCT int local   ${divinearbpct}

    /for i 0 to ${Group.Members}
        /if (${Group.Member[${i}].PctHPs}<=${divinearbpct} && ${Group.Member[${i}].ID}!=NULL && ${Group.Member[${i}].Distance}<=200) {
            /if (${Group.Member[${i}].PctHPs} < ${worstTargetPCT}) {
                /varset worstTargetID ${NetBots[${Group.Member[${i}].Name}].ID}
                /varset worstTargetPCT ${NetBots[${Group.Member[${i}].Name}].PctHPs}
            }
        /varcalc count ${count}+1
        }
    /next i

    /if (${count}>0) {
        /if (${Cast.Ready[Ancient Frozen Aegis of Divinity]}) {
            /if (${broadcast}==1) /${chat} Casting "Ancient Frozen Aegis of Divinity"
            /casting "Ancient Frozen Aegis of Divinity" item
            /return TRUE

        } else /if (${AADivineArbitrationTimer}<=0 && ${Cast.Ready[Divine Arbitration]}) {
            /if (${broadcast}==1) /${chat} Casting "AA Divine Arbitration"
            /casting "Divine Arbitration"
            /call SetGlobalTimer AADivineArbitrationTimer 3m
            /return TRUE
        }
    }

/return FALSE


Sub LayonHands

    /declare count int local            ${NetWorst.Request[radius50 pc war5 shd5]}
    /declare worstTargetID int local    ${NetWorst.Members.Arg[1, ]}

    /if (${count}>0) {
        /if (${AALayonHandsTimer}<=0 && ${Cast.Ready[Lay on Hands]}) {
            /target id ${worstTargetID}
            /delay 5 (${Target.ID}==${worstTargetID})
            /if (${Target.ID}==${worstTargetID}) {
                /alt activate ${AltAbility[Lay on Hands].ID}
                /if (${broadcast}==1) /${chat} Casting "AA Lay on Hands" on [ ${Target.CleanName} - ${Target.PctHPs}% ]
                /if (!${Defined[AALayonHandsTimer]}) /declare AALayonHandsTimer timer global
                /varset AALayonHandsTimer 20m
                /return TRUE
            }
        }
    }

/return FALSE


Sub HealMyPet

    /if (${Me.Class.Name.Equal[Druid]} || ${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Enchanter]} || ${Me.Class.Name.Equal[Magician]} || ${Me.Class.Name.Equal[Necromancer]} || ${Me.Class.Name.Equal[Beastlord]}) {

        /if (${Cast.Ready[${spellPetHeal}]} && ${Me.Pet.ID} && ${Me.Pet.PctHPs}<${autohealpctGT} && ${Me.CurrentMana}>=${Spell[${spellPetHeal}].Mana} && ${Spawn[${Me.Pet.ID}].Distance}<=${Spell[${spellPetHeal}].MyRange}) {
            /if (${broadcast}==1) /${chat} Casting "${spellPetHeal}" on my pet [ ${Target.CleanName} - ${Spawn[${Me.Pet.ID}].PctHPs}% ]
            /casting "${spellPetHeal}"
            /return TRUE
        }
    }

/return FALSE


Sub HealSelfBuff

    | Self Heal Buff

        /if (!${Me.Buff[Eclipse].ID} && ${Int[${Math.Calc[20+${ChaoticAttuning}-${NetBots[${Me.CleanName}].Buff.Count[ ]}]}]} && ${Cast.Ready[Elven Rope]} && !${Me.Moving} && ${ElvenRopeTimer}<=0) {
            /casting "Elven Rope" item
            /call SetGlobalTimer ElvenRopeTimer 3s
            /return TRUE
        }
    
        /if (!${Me.Buff[Improved Healing V].ID} && ${Int[${Math.Calc[20+${ChaoticAttuning}-${NetBots[${Me.CleanName}].Buff.Count[ ]}]}]} && ${Cast.Ready[Blackflame Sphere]} && !${Me.Moving} && ${BlackflameSphereTimer}<=0) {
            /casting "Blackflame Sphere" item
            /call SetGlobalTimer BlackflameSphereTimer 3s
            /return TRUE
        }

        /if (!${Me.Buff[Holy Brilliance I].ID} && ${Int[${Math.Calc[20+${ChaoticAttuning}-${NetBots[${Me.CleanName}].Buff.Count[ ]}]}]} && ${Cast.Ready[Gem Inlaid Shield of Power]} && ${GemInlaidShieldofPowerTimer}<=0) {
            /casting "Gem Inlaid Shield of Power" item
            /call SetGlobalTimer GemInlaidShieldofPowerTimer 3s
            /return TRUE
        }

/return FALSE


Sub ManaCheck
    | Guismo - For HOH Trash
    /if (${Spawn[zradius 10 Arch Bishop Ikliz].Distance} < 100 && ${Spawn[zradius 10 Arch Bishop Ikliz].LineOfSight}) /return FALSE
    /if (${NearestSpawn[zradius 10 A Servant Djinn].Distance} < 200 && ${NearestSpawn[zradius 10 A Servant Djinn].LineOfSight}) /return FALSE

    | By Moguay for skip the SK tanking geather mana
    | /if (${strMainTank.Lower.Find[${Me.CleanName.Lower}]}) /return TRUE

    /if (${Me.PctMana} > 50) /return FALSE

    /if (${ManaCheckTimer}==0) ${broadcastMsg} [Mana check]

    /if (${Cast.Ready} && ${Me.State.Equal[STAND]}) {

        /if (${Type23Timer}==0) {
            /if (${Cast.Ready[Fire Crystal Wristguard]}) {
                /casting "Fire Crystal Wristguard" item
                /call SetGlobalTimer Type23Timer 60s
                /return TRUE
            }
        }

        /if (${Type3Timer}==0 && !${Me.Moving}) {

            /if (${Cast.Ready[Immaculate Glowing Black Stone]}) {
                /casting "Immaculate Glowing Black Stone" item
                /call SetGlobalTimer Type3Timer 241s
                /return TRUE

            } else /if (${Cast.Ready[Flawless Pearl]}) {
                /casting "Flawless Pearl" item
                /call SetGlobalTimer Type3Timer 350s
                /return TRUE

            } else /if (${Cast.Ready[Entropic Orb of Lithluran]}) {
                /casting "Entropic Orb of Lithluran" item
                /call SetGlobalTimer Type3Timer 241s
                /return TRUE

            } else /if (${Cast.Ready[Powerful Silk Slippers]}) {
                /casting "Powerful Silk Slippers" item
                /call SetGlobalTimer Type3Timer 301s
                /return TRUE

            } else /if (${Cast.Ready[Silver Chains of the Burgerz]}) {
                /casting "Silver Chains of the Burgerz" item
                /call SetGlobalTimer Type3Timer 451s
                /return TRUE

            } else /if (${Cast.Ready[Glowing Chains]}) {
                /casting "Glowing Chains" item
                /call SetGlobalTimer Type3Timer 451s
                /return TRUE

            } else /if (${Cast.Ready[Silver Chains]}) {
                /casting "Silver Chains" item
                /call SetGlobalTimer Type3Timer 451s
                /return TRUE

            } else /if (${Cast.Ready[Orb of Spirits]}) {
                /casting "Orb of Spirits" item
                /call SetGlobalTimer Type3Timer 301s
                /return TRUE
            }
        }

        /if (${Type15Timer}==0 && !${Me.Moving}) {

            /if (${Cast.Ready[Tears of Frozen Spirits]}) {
                /casting "Tears of Frozen Spirits" item
                /call SetGlobalTimer Type15Timer 601s
                /return TRUE

            } else /if (${Cast.Ready[Tears of Frozen Mana]}) {
                /casting "Tears of Frozen Mana" item
                /call SetGlobalTimer Type15Timer 601s
                /return TRUE
            }
        }
    }
    /varset ManaCheckTimer 10s

/return FALSE


Sub ManMaintenance

    | Guismo - For HOH Trash
    /if (${Spawn[zradius 10 Arch Bishop Ikliz].Distance} < 100 && ${Spawn[zradius 10 Arch Bishop Ikliz].LineOfSight}) /return FALSE
    /if (${NearestSpawn[zradius 10 A Servant Djinn].Distance} < 200 && ${NearestSpawn[zradius 10 A Servant Djinn].LineOfSight}) /return FALSE


    /if (${Me.Class.Name.Equal[Wizard]}) {

        /if (${Select[${Stick},ON]} && ${Me.Buff[${spellInsidiousHarvest}].ID}) {
        | Unbuff Insidious Harvest if stick
            /if (!${Defined[i]})            /declare i int local                0
            /if (!${Defined[j]})            /declare j int local                0
            /if (!${Defined[intBuff]})      /declare intBuff int local          24
            /if (!${Defined[UnBuffList]})   /declare UnBuffList string local    ${spellInsidiousHarvest}

            /for i 0 to ${intBuff}
                /for j 1 to ${Math.Calc[${UnBuffList.Count[|]}+1]}
                    /if (${Bool[${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip}]} && ${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip.Find[${UnBuffList.Arg[${j},|]}]}) {
                        /if (${broadcast}==1) /${chat} UnBuff: ${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip}
                        /nomodkey /notify BuffWindow Buff${i} leftmouseup
                    }
                /next j
            /next i
        | Buff Insidious Harvest
        } else /if (${Cast.Ready[${spellInsidiousHarvest}]} && ${InsidiousHarvestTimer}<=0 && ${Me.PctMana}<=${ManaMainteance} && !${Select[${Stick},ON]}) {
            /casting "${spellInsidiousHarvest}"
            /call SetGlobalTimer InsidiousHarvestTimer 360s
            /return TRUE
        }
    }

    /if (!${FindItem[Fire Crystal Wristguard].ID}) {

        /if (${Cast.Ready[Bracelet of Eternal Energy]} && ${BraceletofEternalEnergyTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracelet of Eternal Energy" item
            /call SetGlobalTimer BraceletofEternalEnergyTimer 10s
            /return TRUE
        }

        /if (${Cast.Ready[Avilaine's Staff of Chaos]} && ${AvilainesStaffofChaosTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Avilaine's Staff of Chaos" item
            /call SetGlobalTimer AvilainesStaffofChaosTimer 30s
            /return TRUE
        }

        /if (${Cast.Ready[Bracer of Rallos Zek]} && ${BracerofRallosZekTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracer of Rallos Zek" item
            /call SetGlobalTimer BracerofRallosZekTimer 5m
            /return TRUE
        }

        /if (${Cast.Ready[Bracer of Corruption]} && ${BracerofCorruptionTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracer of Corruption" item
            /call SetGlobalTimer BracerofCorruptionTimer 5m
            /return TRUE
        }
    }

    /if (${Me.Class.Name.Equal[Enchanter]}) {

        /if (${Cast.Ready[Gather Mana]} && ${GatherManaTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /alt activate ${AltAbility[Gather Mana].ID}
            /if (${broadcast}==1) /${chat} Casting "AA Gather Mana"
            /varset GatherManaTimer 10m
            /delay 5
            /return TRUE
        }

    }

/return FALSE


Sub SetGlobalTimer(string TimerName, string TimerTimer)

    /multiline ; /if (!${Defined[${TimerName}]}) /declare ${TimerName} timer global; /varset ${TimerName} ${TimerTimer}

/return


Sub Define_CastingWindow

    /declare CastingWindow string outer
    /if (${Bool[${Window[TargetWindow].Child[Casting_SpellName]}]}) /varset CastingWindow TargetWindow
    /if (${Bool[${Window[CastingWindow].Child[Casting_SpellName]}]}) /varset CastingWindow CastingWindow

/return


Sub Define_Echo

    /if (!${Defined[echo]})         /declare echo string global         ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},cecho,echo]}

    /if (!${Defined[CError]})       /declare CError string global       ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+r+],]}
    /if (!${Defined[CCritical]})    /declare CCritical string global    ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+m+],]}
    /if (!${Defined[CWarning]})     /declare CWarning string global     ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+y+],]}
    /if (!${Defined[CNotice]})      /declare CNotice string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+t+],]}
    /if (!${Defined[CNormal]})      /declare CNormal string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+x+],]}
    /if (!${Defined[CAction]})      /declare CAction string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+u+],]}
    /if (!${Defined[Cy]})           /declare Cy string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+y+],]}
    /if (!${Defined[Co]})           /declare Co string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+o+],]}
    /if (!${Defined[Cg]})           /declare Cg string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+g+],]}
    /if (!${Defined[Cu]})           /declare Cu string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+u+],]}
    /if (!${Defined[Cr]})           /declare Cr string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+r+],]}
    /if (!${Defined[Ct]})           /declare Ct string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+t+],]}
    /if (!${Defined[Cb]})           /declare Cb string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+b+],]}
    /if (!${Defined[Cm]})           /declare Cm string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+m+],]}
    /if (!${Defined[Cp]})           /declare Cp string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+p+],]}
    /if (!${Defined[Cw]})           /declare Cw string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+w+],]}
    /if (!${Defined[Cx]})           /declare Cx string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+x+],]}


/return


Sub Define_ChaoticAttuning

    | Configure ChaoticAttuning Variable
    /if (!${Defined[ChaoticAttuning]})      /declare ChaoticAttuning        int     outer   0
    /if (${Me.AltAbility[Chaotic Attuning]} && ${Me.AltAbility[Chaotic Attuning].Cost}) {
                                                                                /varset ChaoticAttuning                                         ${Int[${Math.Calc[${Me.AltAbility[Chaotic Attuning]} / ${Me.AltAbility[Chaotic Attuning].Cost}]}]}
    }
    /if (${Me.AltAbility[Chaotic Attuning].AARankRequired})                     /varset ChaoticAttuning                                         ${Me.AltAbility[Chaotic Attuning].AARankRequired}

/return


Sub Define_THF_Spells

    /if (${Me.Class.Name.Equal[Ranger]}) {
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Sylvan Spring Rk. <RANK>|Sylvan Water|Sylvan Light|Chloroblast|Greater Healing|Healing|Light Healing|Minor Healing|Slave"
    }

    /if (${Me.Class.Name.Equal[Shadow Knight]}) {
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Paladin]}) {
        | Group Heal
        /call SpellCheck "spellGroupHeal" "Blessed Wave Rk. <RANK>|Chaotic Wave|Wave of Piety|Wave of Marr|Wave of Trushar|Healing Wave of Prexus|Wave of Healing|Wave of Life"
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Infusion of Faith Rk. <RANK>|Light of Piety|Light of Order|Light of Nife|Light of Life"
        | Self Heal
        /call SpellCheck "spellBlessingNameless" "Blessing of Nameless Rk. <RANK>"
    }

    /if (${Me.Class.Name.Equal[Cleric]}) {
        | Group Heal
        /call SpellCheck "spellGroupHeal" "Word of Strategy|Word of Vivification|Word of Replenishment|Word of Redemption|Word of Restoration|Word of Vigor|Word of Healing|Word of Health"
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Faithful Light Rk. <RANK>|Ancient: Hallowed Light|True Renewal|Desperate Renewal|Pious Light|Holy Light|Supernal Light|Ethereal Light|Divine Light|Greater Healing Light|Healing Light|Superior Healing|Geater Healing|Healing|Light Healing|Minor Healing"
        | Heal Overtime
        /call SpellCheck "spellHealOverTime" "Faithful Blessing Rk. <RANK>#24s|Chaotic Elixir#24s|Pious Elixir#24s|Holy Elixir#24s|Supernal Elixir#24s|Celestial Elixir#24s|Celestial Healing#24s|Celestial Health#24s|Celestial Remedy#24s"
    }

    /if (${Me.Class.Name.Equal[Shaman]}) {
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Spiritual Touch Rk. <RANK>"
        | Heal Overtime
        /call SpellCheck "spellHealOverTime" "Chaotic Elixir" "Mute"
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Druid]}) {
        | HP V2 Regen
        | /call SpellCheck "spellHealedFriends" "Healed Friends" "Mute"

        | Single Heal
        /call SpellCheck "spellSingleHeal" "Nature's Prayer Rk. <RANK>"
        | Heal Overtime
        /call SpellCheck "spellHealOverTime" "Chaotic Elixir" "Mute"

        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Wizard]}) {

    }

    /if (${Me.Class.Name.Equal[Necromancer]}) {
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Enchanter]}) {
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Magician]}) {
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Beastlord]}) {
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Nature's Beckon Rk. <RANK>|Nature's Beckon"

        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Warrior]}) {

    }

    /if (${Me.Class.Name.Equal[Berserker]}) {

    }

    /if (${Me.Class.Name.Equal[Bard]}) {

    }

    /if (${Me.Class.Name.Equal[Monk]}) {

    }

    /if (${Me.Class.Name.Equal[Rogue]}) {

    }

    | Curses
    | /if (${Select[${Me.Class.Name},Cleric,Paladin,Druid,Shaman]}) {
        | /call SpellCheck "spellRemoveCurse" "Remove Greater Curse|Remove Curse|Remove Lesser Curse|Remove Minor Curse" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Shaman]}) {
        | /call SpellCheck "spellDetrimental" "Pure Spirit" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Cleric,Druid]}) {
        | /call SpellCheck "spellDisease" "Pure Blood" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Cleric]}) {
        | /call SpellCheck "spellPoison" "Antidote" "Mute"
    | }

/return


Sub SpellCheck(SpellVarName,SpellCheckName,SpellVerbose)

    /if (!${SpellCheckName.Length}) /return

    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[SpellCheckName]}) /declare SpellCheckName string local ${SpellCheckName}
    /if (!${Defined[SpellCheckList]}) /declare SpellCheckList string local ${SpellCheckName}
    /if (!${Defined[SpellSetName]}) /declare SpellSetName string local
    /if (!${Defined[SpellCheckLevel]}) /declare SpellCheckLevel int local 0
    /if (!${Defined[SpellFound]}) /declare SpellFound bool local FALSE
    /if (!${Defined[SpellVerbose]}) /declare SpellVerbose string local

    /for j 1 to ${Math.Calc[${SpellCheckList.Count[|]}+1].Int}

        /varset SpellCheckName ${SpellCheckList.Arg[${j},|].Token[1,#]}
        /varset SpellSetName ${SpellCheckList.Arg[${j},|]}

        /if (!${SpellCheckName.Right[7].Equal[ <RANK>]}) {

            /if (${Me.Book["${SpellCheckName}"]} && ${Spell["${SpellCheckName}"].Level} && ${Spell["${SpellCheckName}"].Level} > ${SpellCheckLevel}) {
                /varset SpellFound FALSE

                /if (!${Defined[${SpellVarName}]}) /declare ${SpellVarName} string outer
                /varset ${SpellVarName} ${SpellCheckName}${If[${Bool[${SpellSetName.Token[2,#]}]},#${SpellSetName.Token[2,#]},]}

                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                } else {
                    /docommand /${echo} spell "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                }
                /varset SpellCheckLevel ${Spell["${SpellCheckName}"].Level}
                /varset SpellVerbose Disabled
                /varset SpellFound TRUE
                | /return
            } else /if (${Spell["${SpellCheckName}"].Level} && ${Spell["${SpellCheckName}"].Level} <= ${Me.Level} && ${Spell["${SpellCheckName}"].Level} > ${SpellCheckLevel}) {
                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Cy}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cy}not found${Cx} in book
                } else {
                    /docommand /${echo} spell "${Cy}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cy}not found${Cx} in book
                }
                /varset SpellVerbose Disabled
            } else /if (${Spell["${SpellCheckName}"].ID} && ${Spell["${SpellCheckName}"].Level}==NULL) {
                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Cr}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cr}level not found!${Cx}
                } else {
                    /docommand /${echo} spell "${Cr}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cr}level not found!${Cx}
                }
            }

        } else {

            | Setup spell Rank
            /varset SpellCheckName ${SpellCheckName.Left[${Math.Calc[${SpellCheckName.Length}-7]}]}

            | Init Rank variable
            /if (!${Defined[i]}) /declare i int local
            /if (!${Defined[RankString]}) /declare RankString string local XX|XIX|XVIII|XVII|XVI|XV|XIV|XIII|XII|XI|X|IX|VIII|VII|VI|V|IV|III|II|I

            | Check ranked spell on Book
            /for i 1 to ${Math.Calc[${RankString.Count[|]}+1].Int}
                /if (${Me.Book["${SpellCheckName} ${RankString.Arg[${i},|]}"]} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} > ${SpellCheckLevel}) {
                    /varset SpellFound FALSE

                    /if (!${Defined[${SpellVarName}]}) /declare ${SpellVarName} string outer
                    /varset ${SpellVarName} ${SpellCheckName} ${RankString.Arg[${i},|]}${If[${Bool[${SpellSetName.Token[2,#]}]},#${SpellSetName.Token[2,#]},]}

                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                    } else {
                        /docommand /${echo} spell "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                    }
                    /varset SpellCheckLevel ${Spell["${${SpellVarName}.Arg[1,#]}"].Level}
                    /varset SpellVerbose Disabled
                    /varset SpellFound TRUE
                    | /return
                } else /if (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} <= ${Me.Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} > ${SpellCheckLevel}) {
                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Cy}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in book
                    } else {
                        /docommand /${echo} spell "${Cy}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in book
                    }
                    /varset SpellVerbose Disabled
                } else /if (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].ID} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level}==NULL) {
                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Cr}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cr}level not found!${Cx}
                    } else {
                        /docommand /${echo} spell "${Cr}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cr}level not found!${Cx}
                    }
                }
            /next i

        }

    /next j

    /if (${broadcast}==1 && !${SpellVerbose.Find[Disabled]} && !${SpellVerbose.Find[Mute]}) /${broadcastTell} "No Spell found for: ${SpellVarName} in list: ${SpellCheckList}"
    /if (${broadcast}==1 && !${SpellVerbose.Find[Disabled]}) /docommand /${echo} spell not found for "${Cr}${SpellVarName}${Cx}"
/return


Sub DiscCheck(DiscVarName,DiscCheckName,DiscVerbose)

    /if (!${DiscCheckName.Length}) /return

    /if (!${Defined[countGem]}) /declare countGem int local 0

    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[DiscCheckName]}) /declare DiscCheckName string local ${DiscCheckName}
    /if (!${Defined[DiscCheckList]}) /declare DiscCheckList string local ${DiscCheckName}
    /if (!${Defined[DiscCheckLevel]}) /declare DiscCheckLevel int local 0
    /if (!${Defined[DiscFound]}) /declare DiscFound bool local FALSE
    /if (!${Defined[DiscVerbose]}) /declare DiscVerbose string local

    /for j 1 to ${Math.Calc[${DiscCheckList.Count[|]}+1].Int}

        /varset DiscCheckName ${DiscCheckList.Arg[${j},|].Arg[1,#]}

        /if (!${DiscCheckName.Right[7].Equal[ <RANK>]}) {

            | Check disc
            /if (${Me.CombatAbility["${DiscCheckName}"]} && ${Spell["${DiscCheckName}"].Level} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                /varset DiscFound FALSE
                | Check disc on Combat Ability Window
                /for countGem 1 to 8
                    /if (${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text.Find[${DiscCheckName}]}) {
                        /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                        /varset ${DiscVarName} ${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text}

                        /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-4]}]}) {
                            /docommand /${echo} ${DiscVarName}: "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                        } else {
                            /docommand /${echo} disc "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                        }
                        /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                        /varset DiscVerbose Disabled
                        /varset DiscFound TRUE
                        | /return
                    }
                /next countGem

                /if (!${DiscFound}) {
                    /if (${broadcast}==1) /${broadcastTell} "Disc not memorised in the Combat Skill Bar: ${DiscCheckName}"
                    /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx}" not memorised in the Combat Skill Bar
                    /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                    /varset ${DiscVarName} ${DiscCheckName}
                    /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                    /varset DiscVerbose Disabled
                }
                | /return
            } else /if (${Spell["${DiscCheckName}"].Level} && ${Spell["${DiscCheckName}"].Level} <= ${Me.Level} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                    /docommand /${echo} ${DiscVarName}: "${Cy}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cy}not found${Cx} in Combat Skill
                } else {
                    /docommand /${echo} disc "${Cy}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cy}not found${Cx} in Combat Skill
                }
                /varset DiscVerbose Disabled
            } else /if (${Spell["${DiscCheckName}"].ID} && ${Spell["${DiscCheckName}"].Level}==NULL) {
                /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                    /docommand /${echo} ${DiscVarName}: "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                } else {
                    /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                }
            }

        } else {

            | Setup disc Rank
            /varset DiscCheckName ${DiscCheckName.Left[${Math.Calc[${DiscCheckName.Length}-7]}]}

            | Init Rank variable
            /if (!${Defined[i]}) /declare i int local
            /if (!${Defined[RankString]}) /declare RankString string local XX|XIX|XVIII|XVII|XVI|XV|XIV|XIII|XII|XI|X|IX|VIII|VII|VI|V|IV|III|II|I

            | Check ranked disc on Combat Ability Window
            /for i 1 to ${Math.Calc[${RankString.Count[|]}+1].Int}
                /if (${Me.CombatAbility["${DiscCheckName} ${RankString.Arg[${i},|]}"]} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} > ${DiscCheckLevel}) {
                    /varset DiscFound FALSE
                    | Check disc on Combat Ability Window
                    /for countGem 1 to 8
                        /if (${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text.Equal[${DiscCheckName} ${RankString.Arg[${i},|]}]}) {
                            /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                            /varset ${DiscVarName} ${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text}

                            /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-4]}]}) {
                                /docommand /${echo} ${DiscVarName}: "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                            } else {
                                /docommand /${echo} disc "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                            }
                            /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                            /varset DiscVerbose Disabled
                            /varset DiscFound TRUE
                            | /return
                        }
                    /next countGem

                    /if (!${DiscFound}) {
                        /if (${broadcast}==1) /${broadcastTell} "Disc not memorised in the Combat Skill Bar: ${DiscCheckName} ${RankString.Arg[${i},|]}"
                        /docommand /${echo} disc "${Cr}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx}" not memorised in the Combat Skill Bar
                        /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                        /varset ${DiscVarName} ${DiscCheckName} ${RankString.Arg[${i},|]}
                        /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                        /varset DiscVerbose Disabled
                    }
                    | /return
                } else /if (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} <= ${Me.Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} > ${DiscCheckLevel}) {
                    /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                        /docommand /${echo} ${DiscVarName}: "${Cy}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in Combat Skill
                    } else {
                        /docommand /${echo} disc "${Cy}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in Combat Skill
                    }
                    /varset DiscVerbose Disabled
                } else /if (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].ID} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level}==NULL) {
                    /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                        /docommand /${echo} ${DiscVarName}: "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                    } else {
                        /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                    }
                }
            /next i

        }

    /next j

    /if (${broadcast}==1 && !${DiscVerbose.Find[Disabled]} && !${DiscVerbose.Find[Mute]}) /${broadcastTell} "No disc found for: ${DiscVarName} in list: ${DiscCheckList}"
    /if (${broadcast}==1 && !${DiscVerbose.Find[Disabled]}) /docommand /${echo} disc not found for "${Cr}${DiscVarName}${Cx}"

/return


Sub ListDelbyName(string sList,string sName,string sDiv)
    /if (!${Defined[sDiv]}) /declare sDiv string local |
    /if (!${Defined[${sList}]}) {
        /declare sListLocal string local ${sList}
        /varset sList sListLocal
    }
    /varset ${sList} ${sDiv}${${sList}}${sDiv}${sDiv}
    /declare sright int local
    /declare sleft int local
    /declare splaceholder string local ${sDiv}${${sList}}${sDiv}
    /varcalc sleft  ${splaceholder.Find[${sDiv}${sName}${sDiv}]}-1
    /varset splaceholder ${sName}${sDiv}
    /varcalc sright ${sleft}+${splaceholder.Length}
    /varset ${sList} ${${sList}.Left[${sleft}]}${${sList}.Right[-${sright}]}
    /varset ${sList} ${${sList}.Left[-2].Right[-1]}
    /if (${DebugList.Find[core]}) /echo List ${${sList}}  Deleted: ${sName}
/return ${If[${Defined[sListLocal]},${${sList}},${sList}]}


Sub CheckCasting(string sDelay, string sSubFunction, string sCastReady)

    /declare i          int  local
    /declare bSilence   bool local FALSE
    /declare bReturn    bool local FALSE

    /if (${Defined[sDelay]})            /declare delayTimer         timer   local ${sDelay}

    | Default Filter
    /if (!${Defined[sSubFunction]})     /declare sSubFunction       string  local CAST !QUEUE SILENCE MOVE STAND STUN INVIS
    /if (!${sSubFunction.Length})       /varset sSubFunction        CAST !QUEUE SILENCE MOVE STAND STUN INVIS
    
    :FilterRetry
    | Remove !PARAM
    /for i 1 to ${Math.Calc[${sSubFunction.Count[ ]} + 1]}
        /if (${sSubFunction.Arg[${i}, ].Find[!]}) {
            /call ListDelbyArg "${sSubFunction.Replace[ ,|]}" ${i} " "
            /varset sSubFunction ${Macro.Return}
            /goto :FilterRetry
        }
    /next i

    :waiting
    | Invis
    /if (${Bool[${sSubFunction.Find[INVIS]}]}) {
        /if (${Me.Invis}) /varset bReturn TRUE
    }

    | Move
    /if (${Bool[${sSubFunction.Find[MOVE]}]}) {
        /if (${Me.Moving} || ${Select[${MoveTo},ON]}) /varset bReturn TRUE
    }

    | Silence
    /if (!${FindItem[Mark of Luclin].ID}) {
        /if (${NetBots[${Me.CleanName}].Buff.Find[3011]}) /varset bSilence TRUE
        /if (${NetBots[${Me.CleanName}].Buff.Find[2164]}) /varset bSilence TRUE
        /if (${NetBots[${Me.CleanName}].Silenced}) /varset bSilence TRUE
    }
    /if (${Bool[${sSubFunction.Find[SILENCE]}]} && ${bSilence}) /varset bReturn TRUE

    | Not Stand
    /if (${Bool[${sSubFunction.Find[STAND]}]} && ${Me.State.NotEqual[STAND]}) /varset bReturn TRUE

    | Stun
    /if (${Bool[${sSubFunction.Find[STUN]}]} && ${Me.Stunned}) /varset bReturn TRUE

    | Cast
    /if (${Bool[${sSubFunction.Find[CAST]}]}) {
        | Cast Queue
        /if (${sSubFunction.Find[QUEUE]} && ${CastStep}) /varset bReturn TRUE
        | Casting Item
        /if (${Cast.Active} && (!${Cast.Status.Find[I]} || ${Cast.Status.Equal[C]})) /varset bReturn TRUE

    | Below Bard Twist exclusion
        | Casting
        /if (!(${Me.Class.Name.Equal[Bard]} && ${TwistCheck.Equal[GO]})) {

            /if (${Me.Casting.ID}) /varset bReturn TRUE

            /if (${Cast.Active} && !${Cast.Ready}) /varset bReturn TRUE
            
            /if (${sCastReady.Length} && ${Cast.Active} && !${Cast.Ready[${sCastReady}]}) /varset bReturn TRUE

            /if (${CastingWindow.Equal[CastingWindow]}) {
                /if (${Window[${CastingWindow}].Open}) /varset bReturn TRUE
            } else {
                /if (${Window[${CastingWindow}].Child[Casting_SpellName].Text.Length}) /varset bReturn TRUE
            }
        }
    }

    | Timer Loop
    /if (${delayTimer}) {
        /delay 1
        /goto :waiting
    }

/return ${bReturn}


Sub ListDelbyArg(string sList,int sArg,string sDiv)
    /if (!${Defined[sDiv]}) /declare sDiv string local |
    /if (!${Defined[${sList}]}) {
        /declare sListLocal string local ${sList}
        /varset sList sListLocal
    }    
    /varset ${sList} ${sDiv}${${sList}}${sDiv}${sDiv}
    /declare sright int local
    /declare sleft int local
    /declare splaceholder string local ${${sList}}
    /varset splaceholder ${splaceholder.Arg[${sArg},${sDiv}]}
    /varcalc sleft  ${${sList}.Find[${sDiv}${splaceholder}${sDiv}]}
    /varset splaceholder ${splaceholder}${sDiv}
    /varcalc sright ${sleft}+${splaceholder.Length}
    /varset ${sList} ${${sList}.Left[${sleft}]}${${sList}.Right[-${sright}]}
    /varset ${sList} ${${sList}.Left[-2].Right[-1]}
    /if (${DebugList.Find[core]}) /echo List <${${sList}}> deleted arg ${sArg}
/return ${If[${Defined[sListLocal]},${${sList}},${sList}]}
