Sub Main

| Class exclusion
/if (!${Me.Class.Name.Equal[Cleric]} && !${Me.Class.Name.Equal[Shaman]} && !${Me.Class.Name.Equal[Druid]} && !${Me.Class.Name.Equal[Paladin]} && !${Me.Class.Name.Equal[Ranger]} && !${Me.Class.Name.Equal[Beastlord]}) /return

    /if (!${Plugin[MQ2Cast].Name.Equal[MQ2Cast]})                               /plugin MQ2Cast
    /if (!${Plugin[MQ2EQBC].Name.Equal[MQ2EQBC]})                               /plugin MQ2EQBC
    /if (!${Plugin[MQ2ChatWnd].Name.Equal[MQ2ChatWnd]})                         /plugin mq2chatwnd

    | /if (!${Plugin[mq2custombinds].Name.Equal[mq2custombinds]})                 /plugin mq2custombinds
    | /if (!${Plugin[mq2emusearch].Name.Equal[mq2emusearch]})                     /plugin mq2emusearch
    /if (!${Plugin[mq2labels].Name.Equal[mq2labels]})                           /plugin mq2labels
    /if (!${Plugin[mq2map].Name.Equal[mq2map]})                                 /plugin mq2map

    /if (!${Plugin[MQ2NetBots].Name.Equal[MQ2NetBots]})                         /plugin MQ2NetBots auto
    /if (!${Plugin[MQ2NetHeal].Name.Equal[MQ2NetHeal]})                         /plugin MQ2NetHeal auto
    /if (!${Plugin[MQ2MoveUtils].Name.Equal[MQ2MoveUtils]})                     /plugin MQ2MoveUtils
    | /if (!${Plugin[MQ2Buffblock].Name.Equal[MQ2Buffblock]})                     /plugin MQ2Buffblock
    /if (!${Plugin[MQ2Exchange].Name.Equal[MQ2Exchange]})                       /plugin MQ2Exchange
    | /if (!${Plugin[MQ2EmuAutoMacro].Name.Equal[MQ2EmuAutoMacro]})               /plugin MQ2EmuAutoMacro
    /if (!${Plugin[MQ2AutoGroup].Name.Equal[MQ2AutoGroup]})                     /plugin MQ2AutoGroup
    /if (!${Plugin[MQ2AutoLogin].Name.Equal[MQ2AutoLogin]})                     /plugin MQ2AutoLogin
    | /if (!${Plugin[MQ2EmuMouseAPI].Name.Equal[MQ2EmuMouseAPI]})                 /plugin MQ2EmuMouseAPI
    | /if (!${Plugin[MQ2EmuArt].Name.Equal[MQ2EmuArt]})                           /plugin MQ2EmuArt
    /if (!${Plugin[MQ2ItemDisplay].Name.Equal[MQ2ItemDisplay]})                 /plugin MQ2ItemDisplay

    /if (${Plugin[MQ2Vmqnet].Name.Equal[MQ2Vmqnet]})                            /plugin MQ2Vmqnet unload
    /if (${Plugin[MQ2EmuNetAdvPath].Name.Equal[MQ2EmuNetAdvPath]})              /plugin MQ2EmuNetAdvPath unload
    /if (${Plugin[MQ2EmuMap].Name.Equal[MQ2EmuMap]})                            /plugin MQ2EmuMap unload
    /if (${Plugin[MQ2EmuCharacters].Name.Equal[MQ2EmuCharacters]})              /plugin MQ2EmuCharacters unload
    /if (${Plugin[MQ2DPSAdv].Name.Equal[MQ2DPSAdv]})                            /plugin MQ2DPSAdv unload
    /if (${Plugin[MQ2Melee].Name.Equal[MQ2Melee]})                              /plugin MQ2Melee unload
    /if (${Plugin[MQ2Tracking].Name.Equal[MQ2Tracking]})                        /plugin MQ2Tracking unload

    /if (${Plugin[MQ2Twist].Name.Equal[MQ2Twist]})                              /plugin MQ2Twist unload

    /if (!${Plugin[MQ2FPS].Name.Equal[MQ2FPS]})                                 /plugin MQ2FPS noauto

    /squelch /netbot on send=on grab=on
    /squelch /netheal on send=on grab=on


/if (!${Defined[broadcast]})            /declare broadcast              int     outer   1
/if (!${Defined[broadcastList]})        /declare broadcastList          string  outer   SHEAL GHEAL
/if (!${Defined[broadcastMsg]})         /declare broadcastMsg           string  outer   /echo
| /if (!${Defined[broadcastMsg]})         /declare broadcastMsg           string  outer   /bcaa //echo [${Me.CleanName}]

| % Single Target heal
/if (!${Defined[autohealpctST]})        /declare autohealpctST          int     outer   80
| % Group heal
/if (!${Defined[autohealpctGT]})        /declare autohealpctGT          int     outer   80
| % self pal heal
/if (!${Defined[autohealpctMT]})        /declare autohealpctMT          int     outer   90
| % AA divine
/if (!${Defined[divinearbpct]})         /declare divinearbpct           int     outer   25

| % ManaCheck
/if (!${Defined[Manastart]})            /declare Manastart              int     outer   8
| % ManaMantenance
/if (!${Defined[ManaMainteance]})       /declare ManaMainteance         int     outer   50

/if (!${Defined[autohealpctSHIFT]})     /declare autohealpctSHIFT       int     outer   ${autohealpctST}
/if (!${Defined[autohealpctPARALLEL]})  /declare autohealpctPARALLEL    int     outer   ${autohealpctST}
/if (!${Defined[autogrouppct]})         /declare autogrouppct           int     outer   ${autohealpctGT}
/if (!${Defined[autogroupcount]})       /declare autogroupcount         int     outer   2

/if (!${Defined[DebugList]})            /declare DebugList              string  outer


/call Define_Echo
/call Define_CastingWindow
/call Define_ChaoticAttuning
/call Define_THF_Spells

:Loop
| Wait during casting, !stand, stun, move, silence
    /if (${Me.Casting.ID} || ${Window[CastingWindow].Open} || !${Me.State.Equal[STAND]} || ${Me.Stunned} || ${Me.Moving} || (${Cast.Active} && !${Cast.Status.Find[I]})) {
        /delay 5
        /goto :loop
    }
    /if (!${FindItem[Mark of Luclin].ID}) {
        /if (${NetBots[${Me.CleanName}].Buff.Find[3011]} || ${NetBots[${Me.CleanName}].Buff.Find[2164]}) {
            /delay 5
            /goto :loop
        }
    }

| Geather Mana (NOT IMPLEMENTED)
    /if (${Me.PctMana}<=${Manastart}) /call ManaCheck

| Auto Set HealTarget to Self


| Check to see if Divine Arb needs to be cast.
    /if (${Me.Class.Name.Equal[Cleric]}) /Call DivineArb

| Check to see if Lay on Hands needs to be cast.
    /if (${Me.Class.Name.Equal[Paladin]}) /Call LayonHands

| Check to see if a group heal is required.
    /Call HealGroup

| Check to see if pal self heal is required.
    /Call PalSelfHeal

| Check to see if single heal is required.
    /call HealSingleTarget

| Check for heal pet
    /call HealMyPet

| Check Self heal buff
    /call HealSelfBuff

/goto :Loop
/return


Sub HealSingleTarget

    /if (!${Defined[autohealpctSHIFT]})     /declare autohealpctSHIFT       int     outer   ${autohealpctST}
    /if (!${Defined[autohealpctPARALLEL]})  /declare autohealpctPARALLEL    int     outer   ${autohealpctST}
    /varset autohealpctSHIFT ${autohealpctST}
    /varset autohealpctPARALLEL ${autohealpctST}

    /declare CountTankNeed  int     local   ${NetWorst.Request[radius${Int[${Spell[${spellSingleHeal}].MyRange}]} pc war${autohealpctSHIFT} shd${autohealpctSHIFT}]}
    /declare TankNeedID     string  local
    /varset TankNeedID                      ${NetWorst.Members.Arg[1, ]}
    /declare CountAllNeed   int     local   ${NetWorst.Request[radius${Int[${Spell[${spellSingleHeal}].MyRange}]} pc all${autohealpctPARALLEL}]}
    /declare WorstListID    string  local
    /varset WorstListID                     ${NetWorst.Members}
    /if (${WorstListID.Find[ ]}) /varset WorstListID ${WorstListID.Replace[ ,|]}

    | /declare PriorityType   string  local   bot

    /declare HealerShift    int local   2
    /declare CountMeAll     int local   1

    | Prio Tank/offtank
    | /if (${TankNeedID}!=NULL) {
        | /varset WorstListID ${TankNeedID}
        | /varset PriorityType tank
    | }
    
| Make All Healer Lists - Ordered by priority
    /if (!${Defined[i]}) /declare i int local
    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[k]}) /declare k int local
    /if (!${Defined[l]}) /declare l int local

    /declare HealerTypeList string  local   CLR|SHM|DRU|PAL|RNG

    /for j 1 to ${Math.Calc[${HealerTypeList.Count[|]}+1]}
        /declare CountHealer${HealerTypeList.Arg[${j},|]}   int     local   ${NetWorst.Request[pc ${HealerTypeList.Arg[${j},|].Lower}110]}
        /declare HealerList${HealerTypeList.Arg[${j},|]}    string  local   ${NetWorst.Members}
        /if (${HealerList${HealerTypeList.Arg[${j},|]}.Length}) {
            /if (!${Defined[HealerListID]}) {
                /declare HealerListID string  local ${HealerList${HealerTypeList.Arg[${j},|]}}
            } else {
                /varset HealerListID ${HealerListID} ${HealerList${HealerTypeList.Arg[${j},|]}}
            }
        }
        /if (${DebugList.Find[HEAL]}) /echo HealerList${HealerTypeList.Arg[${j},|]}:${HealerList${HealerTypeList.Arg[${j},|]}} # Count:${CountHealer${HealerTypeList.Arg[${j},|]}}
    /next j

    /declare CountHealer    int     local   ${Math.Calc[${CountHealerPAL} + ${CountHealerCLR} + ${CountHealerSHM} + ${CountHealerDRU} + ${CountHealerRNG}]}

    /if (${DebugList.Find[HEAL]}) /echo HealerListID:${HealerListID} # Count:${CountHealer}

| Shift heal Filter if many toons need heal
    /if (${CountAllNeed} > ${Math.Calc[${CountHealer} - ${HealerShift}]}) {
        /varset CountTankNeed
    }

| Organize All Need Heal Lists
    /if (${CountTankNeed}) {
        /if (${CountAllNeed}) {
            /varset CountAllNeed ${Math.Calc[${CountAllNeed} - 1]}
            /if (${DebugList.Find[HEAL]}) /echo >>> Before ListDelbyName WorstListID=${WorstListID}, TankNeedID=${TankNeedID}
            /call ListDelbyName WorstListID "${TankNeedID}" |
            /if (${DebugList.Find[HEAL]}) /echo >>> After ListDelbyName WorstListID=${WorstListID}.
        }
    }

| Organize Healer Lists By Priority
    /declare CountTank      int     local   0
    /declare CountMeTank    int     local   0
    /declare CountAll       int     local   0
    /declare CountMeAll     int     local   0
    /declare CountFree      int     local   0
    /declare CountMeFree    int     local   0

    /for j 1 to ${Math.Calc[${HealerTypeList.Count[|]}+1]}
        /for i 1 to ${CountHealer${HealerTypeList.Arg[${j},|]}}
            /if (${HealerList${HealerTypeList.Arg[${j},|]}.Length}) {
                /if (${CountTankNeed} && ${CountTank}<${HealerShift}        &&  !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]} &&  ${Math.Distance[${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].Y},${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].X}:${Spawn[id ${TankNeedID}].Y},${Spawn[id ${TankNeedID}].X}]} <= ${Int[${Spell[${spellSingleHeal}].MyRange}]}) {
                    /if (${DebugList.Find[HEAL]}) /echo Add CountTank PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountTank ${Math.Calc[${CountTank} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) /varset CountMeAll ${CountTank}
                } else /if (${CountAllNeed} && ${CountAll}<${CountAllNeed}  &&  !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]} &&  ${Math.Distance[${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].Y},${Spawn[id ${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}].X}:${Spawn[id ${WorstListID.Arg[${Math.Calc[${CountAll} + 1]},|]}].Y},${Spawn[id ${WorstListID.Arg[${Math.Calc[${CountAll} + 1]},|]}].X}]} <= ${Int[${Spell[${spellSingleHeal}].MyRange}]}) {
                    /if (${DebugList.Find[HEAL]}) /echo Add CountALL PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountAll ${Math.Calc[${CountAll} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) /varset CountMeAll ${CountAll}
                } else /if (                                                    !${Int[${NetBots[${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName}].Casting}]}) {
                    /if (${DebugList.Find[HEAL]} && ${DebugList.Find[ALL]}) /echo Add CountFREE PC:${Spawn[id ${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}].CleanName} <${HealerList${HealerTypeList.Arg[${j},|]}}>
                    /varset CountFree ${Math.Calc[${CountFree} + 1]}
                    /if (${Me.ID}==${Int[${HealerList${HealerTypeList.Arg[${j},|]}.Arg[${i}, ]}]}) /varset CountMeFree ${CountFree}
                }
            }
        /next i
    /next j
    
| Debug
    /if (${DebugList.Find[HEAL]} || ${DebugList.Find[TIC]}) {
        /if (${CountTankNeed} || ${CountAllNeed} || ${DebugList.Find[ALL]} || ${DebugList.Find[TIC]}) /echo CountTankNeed=${CountTankNeed} CountAllNeed=${CountAllNeed} CountMeTank=${CountMeTank}/${CountTank} CountMeAll=${CountMeAll}/${CountAll} CountMeFree=${CountMeFree}/${CountFree} WorstListID=${WorstListID}
    }

| Make Parallel Heal    
    /if (${CountMeAll} || (${CountFree} >= ${CountAllNeed} && ${CountAllNeed})) {

        | Dual Parallel Heal
        /if (${CountMeFree}) {
            /varset CountMeAll ${CountMeFree}
        }
            
        | Exit if nobody need heal
        /if (!${WorstListID}!=NULL || !${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].ID}) /return

        /if (${Cast.Ready[${spellSingleHeal}]}) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "${spellSingleHeal}" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /casting "${spellSingleHeal}" -targetid|${WorstListID.Arg[${CountMeAll},|]}
        } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Stone of the Spiritwalker]} && ${StoneoftheSpiritwalkerTimer}<=0) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "Stone of the Spiritwalker" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /casting "Stone of the Spiritwalker" item -targetid|${WorstListID.Arg[${CountMeAll},|]}
            /call SetGlobalTimer  StoneoftheSpiritwalkerTimer 31s
        } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Lava Embroided Cloak]} && ${LavaEmbroidedCloakTimer}<=0) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "Lava Embroided Cloak" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /casting "Lava Embroided Cloak" item -targetid|${WorstListID.Arg[${CountMeAll},|]}
            /call SetGlobalTimer  LavaEmbroidedCloakTimer 31s
        } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Symbol of Apothic Spirits]} && ${SymbolofApothicSpiritsTimer}<=0) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "Symbol of Apothic Spirits" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /casting "Symbol of Apothic Spirits" item -targetid|${WorstListID.Arg[${CountMeAll},|]}
            /call SetGlobalTimer  SymbolofApothicSpiritsTimer 31s
        } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Gloves of the Chaos Slayer]} && ${GlovesoftheChaosSlayerTimer}<=0) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "Gloves of the Chaos Slayer" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /call SetGlobalTimer  GlovesoftheChaosSlayerTimer 16s
            /casting "Gloves of the Chaos Slayer" item -targetid|${WorstListID.Arg[${CountMeAll},|]}
        } else /if (!${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[Leather Bound Mask of Stone]} && ${LeatherBoundMaskofStoneTimer}<=0) {
            /if (${broadcastList.Find[SHEAL]} && ${broadcast}==1 && ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}<=${autohealpctPARALLEL}) ${broadcastMsg} Casting HT "Leather Bound Mask of Stone" on [ ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].CleanName} - ${Spawn[id ${WorstListID.Arg[${CountMeAll},|]}].PctHPs}% ] - ${PriorityType}
            /casting "Leather Bound Mask of Stone" item -targetid|${WorstListID.Arg[${CountMeAll},|]}
            /call SetGlobalTimer  LeatherBoundMaskofStoneTimer 30s
        }
    }

/return


Sub HealGroup

    /if (!${Defined[autogrouppct]}) /declare autogrouppct int outer ${autohealpctGT}
    /varset autogrouppct ${autohealpctGT}

    /declare i int local                0
    /declare count int local            0
    /declare count70 int local          0
    /declare count100 int local         0
    /declare countquick int local       0

    /for i 0 to ${Group.Members}
        /if (${Group.Member[${i}].PctHPs}<=${autogrouppct} && ${Group.Member[${i}].ID}!=NULL && ${Spawn[pc =${Group.Member[${i}].CleanName}].ID}!=NULL && ${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=300) {
             /if (${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=70) /varcalc count70 ${count70}+1
             /if (${Spawn[pc =${Group.Member[${i}].CleanName}].Distance}<=100) /varcalc count100 ${count100}+1
             /if (${Group.Member[${i}].PctHPs}<=60) /varcalc countquick ${countquick}+1
             /varcalc count ${count}+1
        }
    /next i

    /if (${count}>=${autogroupcount}) {

        /if (${countquick} > 0) {
            | /varset CastQueue
            /varset CastStep 0
            /varset CastNum 0
            /if (${Me.Casting.ID} || ${Window[${CastingWindow}].Child[Casting_SpellName].Text.Length} || ${Window[CastingWindow].Open}) /stopcast
            /delay 1s (${Cast.Ready})
            /if (${Me.Moving}) {
                /keypress left
                /keypress right
                /keypress forward
                /keypress back
                /keypress forward
            }
            /if (${Me.Ducking}) /keypress DUCK
        }

        /if ((${Me.Class.Name.Equal[Cleric]} || ${Me.Class.Name.Equal[Paladin]}) && !${Me.Moving}) {

            /if (${Cast.Ready[Sceptre of Marr]} && ${SceptreofMarrTimer}<=0 && ${count100}>=${autogroupcount}) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Sceptre of Marr" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Sceptre of Marr"
                }
                /casting "Sceptre of Marr" item
                /call SetGlobalTimer  SceptreofMarrTimer 5m
                /return

            } else /if (${Cast.Ready[Flindara, Beacon of Light]} && ${FlindaraBeaconofLightTimer}<=0 && ${count100}>=${autogroupcount}) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Flindara, Beacon of Light" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Flindara, Beacon of Light"
                }
                /casting "Flindara, Beacon of Light" item
                /call SetGlobalTimer  FlindaraBeaconofLightTimer 25s
                /return

            } else /if (${Cast.Ready[Hammer of the High Priest]} && ${HammeroftheHighPriestTimer}<=0 && ${count70}>=${autogroupcount}) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Hammer of the High Priest" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Hammer of the High Priest"
                }
                /casting "Hammer of the High Priest" item
                /call SetGlobalTimer  HammeroftheHighPriestTimer 10s
                /return

            } else /if (${Cast.Ready[${spellGroupHeal}]}) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "${spellGroupHeal}" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "${spellGroupHeal}"
                }
                /casting "${spellGroupHeal}"
                /return

            } else /if (${Cast.Ready[Frozen Faithbringer's Breastplate]} && ${FrozenFaithbringersBreastplateTimer}<=0) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Frozen Faithbringer's Breastplate" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Frozen Faithbringer's Breastplate"
                }
                /casting "Frozen Faithbringer's Breastplate" item
                /call SetGlobalTimer FrozenFaithbringersBreastplateTimer 10m
                /return
            }
        }

        /if ((${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Druid]}) && !${Me.Moving}) {

            /if (${Cast.Ready[Immaculate Prism of Life]} && ${ImmaculatePrismofLifeTimer}<=0) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Immaculate Prism of Life" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Immaculate Prism of Life"
                }
                /casting "Immaculate Prism of Life" item
                /call SetGlobalTimer ImmaculatePrismofLifeTimer 15s
                /return

            } else /if (${Cast.Ready[Prism of Corruption]} && ${PrismofCorruptionTimer}<=0) {
                /if (${broadcastList.Find[GHEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Prism of Corruption" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Prism of Corruption"
                }
                /casting "Prism of Corruption" item
                /call SetGlobalTimer PrismofCorruptionTimer 15s
                /return
            }
        }

        /if ((${Me.Class.Name.Equal[Cleric]} || ${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Druid]}) && !${Me.Moving}) {
            /if (${Cast.Ready[Shadowed Boots of Luclin]} && ${ShadowedBootsofLuclinTimer}<=0) {
                /if (${broadcastList.Find[HEAL]}) {
                    /if (${broadcast}==1) ${broadcastMsg} Casting HG "Shadowed Boots of Luclin" - gheal
                } else {
                    /if (${broadcast}==1) /${chat} Casting HG "Shadowed Boots of Luclin"
                }
                /casting "Shadowed Boots of Luclin" item
                /call SetGlobalTimer ShadowedBootsofLuclinTimer 630s
                /return
            }
        }
    }

/return


Sub PalSelfHeal

    /if (${Me.Class.Name.Equal[Paladin]} && ${Cast.Ready[${spellBlessingNameless}]} && ${Me.PctHPs}<${autohealpctMT} && !${Me.Moving}) {
        /if (${broadcast}==1) /${chat} Casting HT "${spellBlessingNameless}" on [ Myself - ${Me.PctHPs}% ]
        /casting "${spellBlessingNameless}"
        /return
    }

/return

Sub DivineArb

    /declare i int local                0
    /declare count int local            0
    /declare worstTargetID int local    0
    /declare worstTargetPCT int local   ${divinearbpct}

    /for i 0 to ${Group.Members}
        /if (${Group.Member[${i}].PctHPs}<=${divinearbpct} && ${Group.Member[${i}].ID}!=NULL && ${Group.Member[${i}].Distance}<=200) {
            /if (${Group.Member[${i}].PctHPs} < ${worstTargetPCT}) {
                /varset worstTargetID ${NetBots[${Group.Member[${i}].Name}].ID}
                /varset worstTargetPCT ${NetBots[${Group.Member[${i}].Name}].PctHPs}
            }
        /varcalc count ${count}+1
        }
    /next i

    /if (${count}>0) {
        /if (${Cast.Ready[Ancient Frozen Aegis of Divinity]}) {
            /if (${broadcast}==1) /${chat} Casting "Ancient Frozen Aegis of Divinity"
            /casting "Ancient Frozen Aegis of Divinity" item
            /return

        } else /if (${AADivineArbitrationTimer}<=0 && ${Cast.Ready[Divine Arbitration]}) {
            /if (${broadcast}==1) /${chat} Casting "AA Divine Arbitration"
            /casting "Divine Arbitration"
            /call SetGlobalTimer AADivineArbitrationTimer 3m
            /return
        }
    }

/return

Sub LayonHands

    /declare count int local            ${NetWorst.Request[radius50 pc war5 shd5]}
    /declare worstTargetID int local    ${NetWorst.Members.Arg[1, ]}

    /if (${count}>0) {
        /if (${AALayonHandsTimer}<=0 && ${Cast.Ready[Lay on Hands]}) {
            /target id ${worstTargetID}
            /delay 5 (${Target.ID}==${worstTargetID})
            /if (${Target.ID}==${worstTargetID}) {
                /alt activate ${AltAbility[Lay on Hands].ID}
                /if (${broadcast}==1) /${chat} Casting "AA Lay on Hands" on [ ${Target.CleanName} - ${Target.PctHPs}% ]
                /if (!${Defined[AALayonHandsTimer]}) /declare AALayonHandsTimer timer global
                /varset AALayonHandsTimer 20m
                /return TRUE
            }
        }
    }

/return FALSE

Sub HealMyPet

    /if (${Me.Class.Name.Equal[Druid]} || ${Me.Class.Name.Equal[Shaman]} || ${Me.Class.Name.Equal[Enchanter]} || ${Me.Class.Name.Equal[Magician]} || ${Me.Class.Name.Equal[Necromancer]} || ${Me.Class.Name.Equal[Beastlord]}) {

        /if (${Cast.Ready[${spellPetHeal}]} && ${Me.Pet.ID} && ${Me.Pet.PctHPs}<${autohealpctGT} && ${Me.CurrentMana}>=${Spell[${spellPetHeal}].Mana} && ${Spawn[${Me.Pet.ID}].Distance}<=${Spell[${spellPetHeal}].MyRange}) {
            /if (${broadcast}==1) /${chat} Casting "${spellPetHeal}" on my pet [ ${Target.CleanName} - ${Spawn[${Me.Pet.ID}].PctHPs}% ]
            /casting "${spellPetHeal}"
            /return
        }
    }

/return

Sub HealSelfBuff

    | Self Heal Buff
        /if (!${Me.Buff[Improved Healing V].ID} && ${Int[${Math.Calc[20+${ChaoticAttuning}-${NetBots[${Me.CleanName}].Buff.Count[ ]}]}]} && ${Cast.Ready[Blackflame Sphere]} && !${Me.Moving} && ${BlackflameSphereTimer}<=0) {
            /casting "Blackflame Sphere" item
            /call SetGlobalTimer BlackflameSphereTimer 3s
            /return
        }

        /if (!${Me.Buff[Holy Brilliance I].ID} && ${Int[${Math.Calc[20+${ChaoticAttuning}-${NetBots[${Me.CleanName}].Buff.Count[ ]}]}]} && ${Cast.Ready[Gem Inlaid Shield of Power]} && ${GemInlaidShieldofPowerTimer}<=0) {
            /casting "Gem Inlaid Shield of Power" item
            /call SetGlobalTimer GemInlaidShieldofPowerTimer 3s
            /return
        }

/return

Sub ManaCheck
    | Guismo - For HOH Trash
    /if (${Spawn[zradius 10 Arch Bishop Ikliz].Distance} < 100 && ${Spawn[zradius 10 Arch Bishop Ikliz].LineOfSight}) /return
    /if (${NearestSpawn[zradius 10 A Servant Djinn].Distance} < 200 && ${NearestSpawn[zradius 10 A Servant Djinn].LineOfSight}) /return

    | By Moguay for skip the SK tanking geather mana
    /if (${strMainTank.Lower.Find[${Me.CleanName.Lower}]}) /return

    /if (${Me.PctMana} > 50) /return

    /if (${ManaCheckTimer}==0) ${broadcastMsg} [Mana check]

    /if (${Cast.Ready} && ${Me.State.Equal[STAND]}) {

        /if (${Type23Timer}==0) {
            /if (${Cast.Ready[Fire Crystal Wristguard]}) {
                /casting "Fire Crystal Wristguard" item
                /call SetGlobalTimer Type23Timer 60s
                /return
            }
        }

        /if (${Type3Timer}==0 && !${Me.Moving}) {

            /if (${Cast.Ready[Immaculate Glowing Black Stone]}) {
                /casting "Immaculate Glowing Black Stone" item
                /call SetGlobalTimer Type3Timer 241s
                /return

            } else /if (${Cast.Ready[Flawless Pearl]}) {
                /casting "Flawless Pearl" item
                /call SetGlobalTimer Type3Timer 350s
                /return

            } else /if (${Cast.Ready[Entropic Orb of Lithluran]}) {
                /casting "Entropic Orb of Lithluran" item
                /call SetGlobalTimer Type3Timer 241s
                /return

            } else /if (${Cast.Ready[Powerful Silk Slippers]}) {
                /casting "Powerful Silk Slippers" item
                /call SetGlobalTimer Type3Timer 301s
                /return

            } else /if (${Cast.Ready[Silver Chains of the Burgerz]}) {
                /casting "Silver Chains of the Burgerz" item
                /call SetGlobalTimer Type3Timer 451s
                /return

            } else /if (${Cast.Ready[Glowing Chains]}) {
                /casting "Glowing Chains" item
                /call SetGlobalTimer Type3Timer 451s
                /return

            } else /if (${Cast.Ready[Silver Chains]}) {
                /casting "Silver Chains" item
                /call SetGlobalTimer Type3Timer 451s
                /return

            } else /if (${Cast.Ready[Orb of Spirits]}) {
                /casting "Orb of Spirits" item
                /call SetGlobalTimer Type3Timer 301s
                /return
            }
        }

        /if (${Type15Timer}==0 && !${Me.Moving}) {

            /if (${Cast.Ready[Tears of Frozen Spirits]}) {
                /casting "Tears of Frozen Spirits" item
                /call SetGlobalTimer Type15Timer 601s
                /return

            } else /if (${Cast.Ready[Tears of Frozen Mana]}) {
                /casting "Tears of Frozen Mana" item
                /call SetGlobalTimer Type15Timer 601s
                /return
            }
        }
    }
    /varset ManaCheckTimer 10s

/return

Sub ManMaintenance

    | Guismo - For HOH Trash
    /if (${Spawn[zradius 10 Arch Bishop Ikliz].Distance} < 100 && ${Spawn[zradius 10 Arch Bishop Ikliz].LineOfSight}) /return
    /if (${NearestSpawn[zradius 10 A Servant Djinn].Distance} < 200 && ${NearestSpawn[zradius 10 A Servant Djinn].LineOfSight}) /return


    /if (${Me.Class.Name.Equal[Wizard]}) {

        /if (${Select[${Stick},ON]} && ${Me.Buff[${spellInsidiousHarvest}].ID}) {
        | Unbuff Insidious Harvest if stick
            /if (!${Defined[i]})            /declare i int local                0
            /if (!${Defined[j]})            /declare j int local                0
            /if (!${Defined[intBuff]})      /declare intBuff int local          24
            /if (!${Defined[UnBuffList]})   /declare UnBuffList string local    ${spellInsidiousHarvest}

            /for i 0 to ${intBuff}
                /for j 1 to ${Math.Calc[${UnBuffList.Count[|]}+1]}
                    /if (${Bool[${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip}]} && ${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip.Find[${UnBuffList.Arg[${j},|]}]}) {
                        /if (${broadcast}==1) /${chat} UnBuff: ${Window[BuffWindow].Child[BW_Buff${i}_Button].Tooltip}
                        /nomodkey /notify BuffWindow Buff${i} leftmouseup
                    }
                /next j
            /next i
        | Buff Insidious Harvest
        } else /if (${Cast.Ready[${spellInsidiousHarvest}]} && ${InsidiousHarvestTimer}<=0 && ${Me.PctMana}<=${ManaMainteance} && !${Select[${Stick},ON]}) {
            /casting "${spellInsidiousHarvest}"
            /call SetGlobalTimer InsidiousHarvestTimer 360s
            /return
        }
    }

    /if (!${FindItem[Fire Crystal Wristguard].ID}) {

        /if (${Cast.Ready[Bracelet of Eternal Energy]} && ${BraceletofEternalEnergyTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracelet of Eternal Energy" item
            /call SetGlobalTimer BraceletofEternalEnergyTimer 10s
            /return
        }

        /if (${Cast.Ready[Avilaine's Staff of Chaos]} && ${AvilainesStaffofChaosTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Avilaine's Staff of Chaos" item
            /call SetGlobalTimer AvilainesStaffofChaosTimer 30s
            /return
        }

        /if (${Cast.Ready[Bracer of Rallos Zek]} && ${BracerofRallosZekTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracer of Rallos Zek" item
            /call SetGlobalTimer BracerofRallosZekTimer 5m
            /return
        }

        /if (${Cast.Ready[Bracer of Corruption]} && ${BracerofCorruptionTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /casting "Bracer of Corruption" item
            /call SetGlobalTimer BracerofCorruptionTimer 5m
            /return
        }
    }

    /if (${Me.Class.Name.Equal[Enchanter]}) {

        /if (${Cast.Ready[Gather Mana]} && ${GatherManaTimer}<=0 && ${Me.PctMana}<=${ManaMainteance}) {
            /alt activate ${AltAbility[Gather Mana].ID}
            /if (${broadcast}==1) /${chat} Casting "AA Gather Mana"
            /varset GatherManaTimer 10m
            /delay 5
            /return
        }

    }

/return

Sub SetGlobalTimer(string TimerName, string TimerTimer)

    /multiline ; /if (!${Defined[${TimerName}]}) /declare ${TimerName} timer global; /varset ${TimerName} ${TimerTimer}

/return

Sub Define_CastingWindow

    /declare CastingWindow string outer
    /if (${Bool[${Window[TargetWindow].Child[Casting_SpellName]}]}) /varset CastingWindow TargetWindow
    /if (${Bool[${Window[CastingWindow].Child[Casting_SpellName]}]}) /varset CastingWindow CastingWindow

/return

Sub Define_Echo

    /if (!${Defined[echo]})         /declare echo string global         ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},cecho,echo]}

    /if (!${Defined[CError]})       /declare CError string global       ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+r+],]}
    /if (!${Defined[CCritical]})    /declare CCritical string global    ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+m+],]}
    /if (!${Defined[CWarning]})     /declare CWarning string global     ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+y+],]}
    /if (!${Defined[CNotice]})      /declare CNotice string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+t+],]}
    /if (!${Defined[CNormal]})      /declare CNormal string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+x+],]}
    /if (!${Defined[CAction]})      /declare CAction string global      ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+u+],]}
    /if (!${Defined[Cy]})           /declare Cy string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+y+],]}
    /if (!${Defined[Co]})           /declare Co string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+o+],]}
    /if (!${Defined[Cg]})           /declare Cg string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+g+],]}
    /if (!${Defined[Cu]})           /declare Cu string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+u+],]}
    /if (!${Defined[Cr]})           /declare Cr string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+r+],]}
    /if (!${Defined[Ct]})           /declare Ct string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+t+],]}
    /if (!${Defined[Cb]})           /declare Cb string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+b+],]}
    /if (!${Defined[Cm]})           /declare Cm string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+m+],]}
    /if (!${Defined[Cp]})           /declare Cp string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+p+],]}
    /if (!${Defined[Cw]})           /declare Cw string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+w+],]}
    /if (!${Defined[Cx]})           /declare Cx string global           ${If[${Plugin[MQ2CEcho].Name.Equal[MQ2CEcho]},[+x+],]}


/return

Sub Define_ChaoticAttuning

    | Configure ChaoticAttuning Variable
    /if (!${Defined[ChaoticAttuning]})      /declare ChaoticAttuning        int     outer   0
    /if (${Me.AltAbility[Chaotic Attuning]} && ${Me.AltAbility[Chaotic Attuning].Cost}) {
                                                                                /varset ChaoticAttuning                                         ${Int[${Math.Calc[${Me.AltAbility[Chaotic Attuning]} / ${Me.AltAbility[Chaotic Attuning].Cost}]}]}
    }
    /if (${Me.AltAbility[Chaotic Attuning].AARankRequired})                     /varset ChaoticAttuning                                         ${Me.AltAbility[Chaotic Attuning].AARankRequired}

/return

Sub Define_THF_Spells

    /if (${Me.Class.Name.Equal[Ranger]}) {
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Sylvan Spring Rk. <RANK>|Sylvan Water|Sylvan Light|Chloroblast|Greater Healing|Healing|Light Healing|Minor Healing|Slave"
    }

    /if (${Me.Class.Name.Equal[Shadow Knight]}) {
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
        | Life Tap
        /call SpellCheck "spellLifeTap1" "Grasp of Death Rk. <RANK>"
        /call SpellCheck "spellLifeTap2" "Touch of the Devourer|Touch of Draygun|Touch of Inruku|Touch of Innoruuk|Touch of Volatis|Drain Soul|Drain Spirit|Spirit Tap|Siphon Life|Life Leech|Lifedraw|Lifespike|Lifetap"
    }

    /if (${Me.Class.Name.Equal[Paladin]}) {
        | Heal
        /call SpellCheck "spellGroupHeal" "Blessed Wave Rk. <RANK>|Chaotic Wave|Wave of Piety|Wave of Marr|Wave of Trushar|Healing Wave of Prexus|Wave of Healing|Wave of Life"
        /call SpellCheck "spellSingleHeal" "Infusion of Faith Rk. <RANK>|Light of Piety|Light of Order|Light of Nife|Light of Life"
        /call SpellCheck "spellBlessingNameless" "Blessing of Nameless Rk. <RANK>"
    }

    /if (${Me.Class.Name.Equal[Cleric]}) {
        | Heal
        /call SpellCheck "spellGroupHeal" "Word of Strategy|Word of Vivification|Word of Replenishment|Word of Redemption|Word of Restoration|Word of Vigor|Word of Healing|Word of Health"
        /call SpellCheck "spellSingleHeal" "Faithful Light Rk. <RANK>|Ancient: Hallowed Light|True Renewal|Desperate Renewal|Pious Light|Holy Light|Supernal Light|Ethereal Light|Divine Light|Greater Healing Light|Healing Light|Superior Healing|Geater Healing|Healing|Light Healing|Minor Healing"
        /call SpellCheck "spellHealOverTime" "Faithful Blessing Rk. <RANK>#24s|Chaotic Elixir#24s|Pious Elixir#24s|Holy Elixir#24s|Supernal Elixir#24s|Celestial Elixir#24s|Celestial Healing#24s|Celestial Health#24s|Celestial Remedy#24s"
    }

    /if (${Me.Class.Name.Equal[Shaman]}) {
        | Heal
        /call SpellCheck "spellHealOverTime" "Chaotic Elixir" "Mute"
        /call SpellCheck "spellSingleHeal" "Spiritual Touch Rk. <RANK>"
        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Druid]}) {
        /call SpellCheck "spellHealedFriends" "Healed Friends" "Mute"

        /call SpellCheck "spellSingleHeal" "Nature's Prayer Rk. <RANK>"
        /call SpellCheck "spellHealOverTime" "Chaotic Elixir" "Mute"

        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Wizard]}) {

    }

    /if (${Me.Class.Name.Equal[Necromancer]}) {
        /call SpellCheck "spellLifeTap1" "Grasp of the Reaper Rk. <RANK>"
        /call SpellCheck "spellLifeTap2" "Soul Theft <RANK>|Soulspike"

        /call SpellCheck "spellPet" "Void of Death Rk. <RANK>"
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Enchanter]}) {
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Magician]}) {
        /call SpellCheck "spellPet" "Elemental Essence Rk. <RANK>"
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Beastlord]}) {
        | Single Heal
        /call SpellCheck "spellSingleHeal" "Nature's Beckon Rk. <RANK>|Nature's Beckon"

        | Pet Heal
        /call SpellCheck "spellPetHeal" "Tactical Renewal|Renewal of Chaos"
    }

    /if (${Me.Class.Name.Equal[Warrior]}) {

    }

    /if (${Me.Class.Name.Equal[Berserker]}) {

    }

    /if (${Me.Class.Name.Equal[Bard]}) {

    }

    /if (${Me.Class.Name.Equal[Monk]}) {

    }

    /if (${Me.Class.Name.Equal[Rogue]}) {

    }

    | Curses
    | /if (${Select[${Me.Class.Name},Cleric,Paladin,Druid,Shaman]}) {
        | /call SpellCheck "spellRemoveCurse" "Remove Greater Curse|Remove Curse|Remove Lesser Curse|Remove Minor Curse" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Shaman]}) {
        | /call SpellCheck "spellDetrimental" "Pure Spirit" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Cleric,Druid]}) {
        | /call SpellCheck "spellDisease" "Pure Blood" "Mute"
    | }
    | /if (${Select[${Me.Class.Name},Cleric]}) {
        | /call SpellCheck "spellPoison" "Antidote" "Mute"
    | }

/return

Sub SpellCheck(SpellVarName,SpellCheckName,SpellVerbose)

    /if (!${SpellCheckName.Length}) /return

    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[SpellCheckName]}) /declare SpellCheckName string local ${SpellCheckName}
    /if (!${Defined[SpellCheckList]}) /declare SpellCheckList string local ${SpellCheckName}
    /if (!${Defined[SpellSetName]}) /declare SpellSetName string local
    /if (!${Defined[SpellCheckLevel]}) /declare SpellCheckLevel int local 0
    /if (!${Defined[SpellFound]}) /declare SpellFound bool local FALSE
    /if (!${Defined[SpellVerbose]}) /declare SpellVerbose string local

    /for j 1 to ${Math.Calc[${SpellCheckList.Count[|]}+1].Int}

        /varset SpellCheckName ${SpellCheckList.Arg[${j},|].Token[1,#]}
        /varset SpellSetName ${SpellCheckList.Arg[${j},|]}

        /if (!${SpellCheckName.Right[7].Equal[ <RANK>]}) {

            /if (${Me.Book["${SpellCheckName}"]} && ${Spell["${SpellCheckName}"].Level} && ${Spell["${SpellCheckName}"].Level} > ${SpellCheckLevel}) {
                /varset SpellFound FALSE

                /if (!${Defined[${SpellVarName}]}) /declare ${SpellVarName} string outer
                /varset ${SpellVarName} ${SpellCheckName}${If[${Bool[${SpellSetName.Token[2,#]}]},#${SpellSetName.Token[2,#]},]}

                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                } else {
                    /docommand /${echo} spell "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                }
                /varset SpellCheckLevel ${Spell["${SpellCheckName}"].Level}
                /varset SpellVerbose Disabled
                /varset SpellFound TRUE
                | /return
            } else /if (${Spell["${SpellCheckName}"].Level} && ${Spell["${SpellCheckName}"].Level} <= ${Me.Level} && ${Spell["${SpellCheckName}"].Level} > ${SpellCheckLevel}) {
                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Cy}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cy}not found${Cx} in book
                } else {
                    /docommand /${echo} spell "${Cy}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cy}not found${Cx} in book
                }
                /varset SpellVerbose Disabled
            } else /if (${Spell["${SpellCheckName}"].ID} && ${Spell["${SpellCheckName}"].Level}==NULL) {
                /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                    /docommand /${echo} ${SpellVarName}: "${Cr}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cr}level not found!${Cx}
                } else {
                    /docommand /${echo} spell "${Cr}${SpellCheckName}${Cx} (${Spell["${SpellCheckName}"].Level})" ${Cr}level not found!${Cx}
                }
            }

        } else {

            | Setup spell Rank
            /varset SpellCheckName ${SpellCheckName.Left[${Math.Calc[${SpellCheckName.Length}-7]}]}

            | Init Rank variable
            /if (!${Defined[i]}) /declare i int local
            /if (!${Defined[RankString]}) /declare RankString string local XX|XIX|XVIII|XVII|XVI|XV|XIV|XIII|XII|XI|X|IX|VIII|VII|VI|V|IV|III|II|I

            | Check ranked spell on Book
            /for i 1 to ${Math.Calc[${RankString.Count[|]}+1].Int}
                /if (${Me.Book["${SpellCheckName} ${RankString.Arg[${i},|]}"]} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} > ${SpellCheckLevel}) {
                    /varset SpellFound FALSE

                    /if (!${Defined[${SpellVarName}]}) /declare ${SpellVarName} string outer
                    /varset ${SpellVarName} ${SpellCheckName} ${RankString.Arg[${i},|]}${If[${Bool[${SpellSetName.Token[2,#]}]},#${SpellSetName.Token[2,#]},]}

                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                    } else {
                        /docommand /${echo} spell "${Co}${${SpellVarName}.Arg[1,#]}${Cx} (${Spell["${${SpellVarName}.Arg[1,#]}"].Level})" found${If[${Bool[${SpellSetName.Token[2,#]}]}, - ${SpellSetName.Token[2,#]},]}
                    }
                    /varset SpellCheckLevel ${Spell["${${SpellVarName}.Arg[1,#]}"].Level}
                    /varset SpellVerbose Disabled
                    /varset SpellFound TRUE
                    | /return
                } else /if (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} <= ${Me.Level} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level} > ${SpellCheckLevel}) {
                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Cy}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in book
                    } else {
                        /docommand /${echo} spell "${Cy}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in book
                    }
                    /varset SpellVerbose Disabled
                } else /if (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].ID} && ${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level}==NULL) {
                    /if (${Int[${SpellVarName.Right[1]}]} || !${SpellCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${SpellVarName.Right[-5]}]}) {
                        /docommand /${echo} ${SpellVarName}: "${Cr}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cr}level not found!${Cx}
                    } else {
                        /docommand /${echo} spell "${Cr}${SpellCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${SpellCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cr}level not found!${Cx}
                    }
                }
            /next i

        }

    /next j

    /if (${broadcast}==1 && !${SpellVerbose.Find[Disabled]} && !${SpellVerbose.Find[Mute]}) /${broadcastTell} "No Spell found for: ${SpellVarName} in list: ${SpellCheckList}"
    /if (${broadcast}==1 && !${SpellVerbose.Find[Disabled]}) /docommand /${echo} spell not found for "${Cr}${SpellVarName}${Cx}"
/return

Sub DiscCheck(DiscVarName,DiscCheckName,DiscVerbose)

    /if (!${DiscCheckName.Length}) /return

    /if (!${Defined[countGem]}) /declare countGem int local 0

    /if (!${Defined[j]}) /declare j int local
    /if (!${Defined[DiscCheckName]}) /declare DiscCheckName string local ${DiscCheckName}
    /if (!${Defined[DiscCheckList]}) /declare DiscCheckList string local ${DiscCheckName}
    /if (!${Defined[DiscCheckLevel]}) /declare DiscCheckLevel int local 0
    /if (!${Defined[DiscFound]}) /declare DiscFound bool local FALSE
    /if (!${Defined[DiscVerbose]}) /declare DiscVerbose string local

    /for j 1 to ${Math.Calc[${DiscCheckList.Count[|]}+1].Int}

        /varset DiscCheckName ${DiscCheckList.Arg[${j},|].Arg[1,#]}

        /if (!${DiscCheckName.Right[7].Equal[ <RANK>]}) {

            | Check disc
            /if (${Me.CombatAbility["${DiscCheckName}"]} && ${Spell["${DiscCheckName}"].Level} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                /varset DiscFound FALSE
                | Check disc on Combat Ability Window
                /for countGem 1 to 8
                    /if (${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text.Find[${DiscCheckName}]}) {
                        /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                        /varset ${DiscVarName} ${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text}

                        /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-4]}]}) {
                            /docommand /${echo} ${DiscVarName}: "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                        } else {
                            /docommand /${echo} disc "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                        }
                        /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                        /varset DiscVerbose Disabled
                        /varset DiscFound TRUE
                        | /return
                    }
                /next countGem

                /if (!${DiscFound}) {
                    /if (${broadcast}==1) /${broadcastTell} "Disc not memorised in the Combat Skill Bar: ${DiscCheckName}"
                    /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx}" not memorised in the Combat Skill Bar
                    /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                    /varset ${DiscVarName} ${DiscCheckName}
                    /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                    /varset DiscVerbose Disabled
                }
                | /return
            } else /if (${Spell["${DiscCheckName}"].Level} && ${Spell["${DiscCheckName}"].Level} <= ${Me.Level} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                    /docommand /${echo} ${DiscVarName}: "${Cy}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cy}not found${Cx} in Combat Skill
                } else {
                    /docommand /${echo} disc "${Cy}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cy}not found${Cx} in Combat Skill
                }
                /varset DiscVerbose Disabled
            } else /if (${Spell["${DiscCheckName}"].ID} && ${Spell["${DiscCheckName}"].Level}==NULL) {
                /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                    /docommand /${echo} ${DiscVarName}: "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                } else {
                    /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                }
            }

        } else {

            | Setup disc Rank
            /varset DiscCheckName ${DiscCheckName.Left[${Math.Calc[${DiscCheckName.Length}-7]}]}

            | Init Rank variable
            /if (!${Defined[i]}) /declare i int local
            /if (!${Defined[RankString]}) /declare RankString string local XX|XIX|XVIII|XVII|XVI|XV|XIV|XIII|XII|XI|X|IX|VIII|VII|VI|V|IV|III|II|I

            | Check ranked disc on Combat Ability Window
            /for i 1 to ${Math.Calc[${RankString.Count[|]}+1].Int}
                /if (${Me.CombatAbility["${DiscCheckName} ${RankString.Arg[${i},|]}"]} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} > ${DiscCheckLevel}) {
                    /varset DiscFound FALSE
                    | Check disc on Combat Ability Window
                    /for countGem 1 to 8
                        /if (${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text.Equal[${DiscCheckName} ${RankString.Arg[${i},|]}]}) {
                            /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                            /varset ${DiscVarName} ${Window[CombatAbilityWnd].Child[CAW_Button${countGem}].Text}

                            /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-4]}]}) {
                                /docommand /${echo} ${DiscVarName}: "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                            } else {
                                /docommand /${echo} disc "${Co}${${DiscVarName}}${Cx} (${Spell["${${DiscVarName}}"].Level})" found
                            }
                            /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                            /varset DiscVerbose Disabled
                            /varset DiscFound TRUE
                            | /return
                        }
                    /next countGem

                    /if (!${DiscFound}) {
                        /if (${broadcast}==1) /${broadcastTell} "Disc not memorised in the Combat Skill Bar: ${DiscCheckName} ${RankString.Arg[${i},|]}"
                        /docommand /${echo} disc "${Cr}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx}" not memorised in the Combat Skill Bar
                        /if (!${Defined[${DiscVarName}]}) /declare ${DiscVarName} string outer
                        /varset ${DiscVarName} ${DiscCheckName} ${RankString.Arg[${i},|]}
                        /varset DiscCheckLevel ${Spell["${${DiscVarName}}"].Level}
                        /varset DiscVerbose Disabled
                    }
                    | /return
                } else /if (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} <= ${Me.Level} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level} > ${DiscCheckLevel}) {
                    /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]}) {
                        /docommand /${echo} ${DiscVarName}: "${Cy}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in Combat Skill
                    } else {
                        /docommand /${echo} disc "${Cy}${DiscCheckName} ${RankString.Arg[${i},|]}${Cx} (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level})" ${Cy}not found${Cx} in Combat Skill
                    }
                    /varset DiscVerbose Disabled
                } else /if (${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].ID} && ${Spell["${DiscCheckName} ${RankString.Arg[${i},|]}"].Level}==NULL) {
                    /if (${Int[${DiscVarName.Right[1]}]} || !${DiscCheckName.Replace[ ,].Replace[:,].Replace[',].Find[${DiscVarName.Right[-5]}]} && ${Spell["${DiscCheckName}"].Level} > ${DiscCheckLevel}) {
                        /docommand /${echo} ${DiscVarName}: "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                    } else {
                        /docommand /${echo} disc "${Cr}${DiscCheckName}${Cx} (${Spell["${DiscCheckName}"].Level})" ${Cr}level not found!${Cx}
                    }
                }
            /next i

        }

    /next j

    /if (${broadcast}==1 && !${DiscVerbose.Find[Disabled]} && !${DiscVerbose.Find[Mute]}) /${broadcastTell} "No disc found for: ${DiscVarName} in list: ${DiscCheckList}"
    /if (${broadcast}==1 && !${DiscVerbose.Find[Disabled]}) /docommand /${echo} disc not found for "${Cr}${DiscVarName}${Cx}"

/return

Sub ListDelbyName(string sList,string sName,string sDiv)
    /if (!${Defined[sDiv]}) /declare sDiv string local |
    /if (!${Defined[${sList}]}) {
        /declare sListLocal string local ${sList}
        /varset sList sListLocal
    }
    /varset ${sList} ${sDiv}${${sList}}${sDiv}${sDiv}
    /declare sright int local
    /declare sleft int local
    /declare splaceholder string local ${sDiv}${${sList}}${sDiv}
    /varcalc sleft  ${splaceholder.Find[${sDiv}${sName}${sDiv}]}-1
    /varset splaceholder ${sName}${sDiv}
    /varcalc sright ${sleft}+${splaceholder.Length}
    /varset ${sList} ${${sList}.Left[${sleft}]}${${sList}.Right[-${sright}]}
    /varset ${sList} ${${sList}.Left[-2].Right[-1]}
    /if (${DebugList.Find[core]}) /echo List ${${sList}}  Deleted: ${sName}
/return ${If[${Defined[sListLocal]},${${sList}},${sList}]}